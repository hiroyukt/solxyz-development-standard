# 2. Javaコーディング規約

- [2. Javaコーディング規約](#2-javaコーディング規約)
  - [2.1. パッケージ構成](#21-パッケージ構成)
    - [2.1.1. 方式設計上の適した形にしたがってパッケージを構成してください](#211-方式設計上の適した形にしたがってパッケージを構成してください)
  - [2.2. ソースファイルの基本事項](#22-ソースファイルの基本事項)
    - [2.2.1. ファイルエンコーディング](#221-ファイルエンコーディング)
    - [2.2.2. 特殊文字](#222-特殊文字)
    - [2.2.3. ソースファイル構造](#223-ソースファイル構造)
  - [2.3. 全般](#23-全般)
    - [2.3.1. 原則としてオブジェクトの参照にはインターフェースを利用します](#231-原則としてオブジェクトの参照にはインターフェースを利用します)
    - [2.3.2. DeprecatedされたAPIの使用を禁止します](#232-deprecatedされたapiの使用を禁止します)
    - [2.3.3. アクセス修飾子は適切な権限で宣言してください](#233-アクセス修飾子は適切な権限で宣言してください)
    - [2.3.4. finalを利用することを推奨します](#234-finalを利用することを推奨します)
    - [2.3.5. if文などの条件式でbooleanと比較しないでください](#235-if文などの条件式でbooleanと比較しないでください)
  - [2.4. 命名](#24-命名)
    - [2.4.1. クラス名は基本的には名詞とし、必要に応じて方式設計上の規則にしたがって命名してください](#241-クラス名は基本的には名詞とし必要に応じて方式設計上の規則にしたがって命名してください)
    - [2.4.2. メソッド名は基本的には動詞から始まるように命名をしてください](#242-メソッド名は基本的には動詞から始まるように命名をしてください)
    - [2.4.3. 変数は基本的には名詞で命名してください](#243-変数は基本的には名詞で命名してください)
    - [2.4.4. データモデルの用語辞書を活用して命名してください](#244-データモデルの用語辞書を活用して命名してください)
  - [2.6. 禁止事項](#26-禁止事項)
    - [2.6.1. 計算式の途中でインクリメント・デクリメントをしないでください](#261-計算式の途中でインクリメントデクリメントをしないでください)
    - [2.6.2. フィールド（メンバー変数）を一時変数として使用しないでください](#262-フィールドメンバー変数を一時変数として使用しないでください)
    - [2.6.3. スーパークラスと同名のフィールドをサブクラスで定義しないでください](#263-スーパークラスと同名のフィールドをサブクラスで定義しないでください)
    - [2.6.4. 戻り値がコレクションや配列の場合は null を返さないでください](#264-戻り値がコレクションや配列の場合は-null-を返さないでください)
    - [2.6.5. コンストラクタ内で自分自身のインスタンスメソッドを呼び出さないようにしてください](#265-コンストラクタ内で自分自身のインスタンスメソッドを呼び出さないようにしてください)
    - [2.6.6. インスタンスが格納された変数をレシーバにして`static`メソッドを呼び出さないでください](#266-インスタンスが格納された変数をレシーバにしてstaticメソッドを呼び出さないでください)
    - [2.6.7. インスタンスが格納された変数をレシーバにして`static`変数を参照しないでください](#267-インスタンスが格納された変数をレシーバにしてstatic変数を参照しないでください)
    - [2.6.8. アプリケーションプログラマーの独断で例外クラスは作らないでください](#268-アプリケーションプログラマーの独断で例外クラスは作らないでください)
    - [2.6.9. java.lang.Exceptionクラスのインスタンスを生成してスローしないでください](#269-javalangexceptionクラスのインスタンスを生成してスローしないでください)
    - [2.6.10. try-catch 文を条件分岐のために使用しないでください](#2610-try-catch-文を条件分岐のために使用しないでください)
    - [2.6.11. 秘匿情報はログ出力やシリアライズされないように注意してください](#2611-秘匿情報はログ出力やシリアライズされないように注意してください)
    - [2.6.12. Java標準ライブラリにあるレガシーなAPIは使用しないでください](#2612-java標準ライブラリにあるレガシーなapiは使用しないでください)
    - [2.6.13. リフレクションを直接使用しないでください](#2613-リフレクションを直接使用しないでください)
    - [2.6.14. クラスを不整合な状態にしないでください](#2614-クラスを不整合な状態にしないでください)
    - [2.6.15. アプリケーションプログラマーの独断でスレッドを作って非同期処理をしないでください](#2615-アプリケーションプログラマーの独断でスレッドを作って非同期処理をしないでください)
  - [2.7. Java構文](#27-java構文)
    - [2.7.1. インポート](#271-インポート)
      - [2.7.1.1. インポート文の順序](#2711-インポート文の順序)
      - [2.7.1.2. `java.lang`パッケージはインポートを禁止します](#2712-javalangパッケージはインポートを禁止します)
      - [2.7.1.3. staticインポートを禁止します](#2713-staticインポートを禁止します)
      - [2.7.1.4. オンデマンド型インポート宣言を禁止します](#2714-オンデマンド型インポート宣言を禁止します)
    - [2.7.2. コンストラクタ](#272-コンストラクタ)
      - [2.7.2.1. public宣言していないクラスには`public`権限のコンストラクタの作成を禁止します](#2721-public宣言していないクラスにはpublic権限のコンストラクタの作成を禁止します)
      - [2.7.2.2. インスタンスメンバを持たない（staticメンバのみの）クラスは、`private`権限のコンストラクタを作成します](#2722-インスタンスメンバを持たないstaticメンバのみのクラスはprivate権限のコンストラクタを作成します)
    - [2.7.3. メソッド](#273-メソッド)
      - [2.7.3.1. オーバーライドさせたくないメソッドは`final`を利用します](#2731-オーバーライドさせたくないメソッドはfinalを利用します)
      - [2.7.3.2. 戻り値が配列のメソッドで、戻る配列のサイズが0の場合、メソッドを使用するクライアントの余計なnullチェックのロジックを回避するため、nullではなく長さゼロの配列を返却します](#2732-戻り値が配列のメソッドで戻る配列のサイズが0の場合メソッドを使用するクライアントの余計なnullチェックのロジックを回避するためnullではなく長さゼロの配列を返却します)
      - [2.7.3.3. メソッドは1つの役割にします](#2733-メソッドは1つの役割にします)
    - [2.7.4. クラスメソッド](#274-クラスメソッド)
      - [2.7.4.1. クラスメソッドを利用するときは、クラス名を使って呼び出します](#2741-クラスメソッドを利用するときはクラス名を使って呼び出します)
    - [2.7.5. 変数全般](#275-変数全般)
      - [2.7.5.1. つのステートメントには1つの変数宣言します](#2751-つのステートメントには1つの変数宣言します)
      - [2.7.5.2. リテラルの使用を禁止します](#2752-リテラルの使用を禁止します)
      - [2.7.5.3. リテラル定数の名前はその値の意味を正しく表現したものにします](#2753-リテラル定数の名前はその値の意味を正しく表現したものにします)
      - [2.7.5.4. 配列宣言は「`型名[]`」にします](#2754-配列宣言は型名にします)
      - [2.7.5.5. できるだけローカル変数を利用します](#2755-できるだけローカル変数を利用します)
    - [2.7.6. 定数](#276-定数)
      - [2.7.6.1. `public`で宣言するクラス変数とインスタンス変数は、定数のみとし、`static final`で定義します](#2761-publicで宣言するクラス変数とインスタンス変数は定数のみとしstatic-finalで定義します)
      - [2.7.6.2. 定数（`static`フィールド）に、`static`ではないメソッドからの書き込みを強く推奨しません](#2762-定数staticフィールドにstaticではないメソッドからの書き込みを強く推奨しません)
      - [2.7.6.3. 定数は、プリミティブ型もしくは、不変（Immutable）オブジェクトで参照します](#2763-定数はプリミティブ型もしくは不変immutableオブジェクトで参照します)
      - [2.7.6.4. 不変`List`の生成には`List.of()`を利用します](#2764-不変listの生成にはlistofを利用します)
      - [2.7.6.5. 不変`Set`の生成には`Set.of()`を利用します](#2765-不変setの生成にはsetofを利用します)
      - [2.7.6.6. 不変`Map`の生成には`Map.of()`を利用します](#2766-不変mapの生成にはmapofを利用します)
      - [2.7.6.7. 不変な配列インスタンスは長さ0の配列以外は生成不可能なため、外部から参照される（`public`）定数では利用せず、`List`等への置き換えをしてください](#2767-不変な配列インスタンスは長さ0の配列以外は生成不可能なため外部から参照されるpublic定数では利用せずlist等への置き換えをしてください)
    - [2.7.7. インスタンス変数](#277-インスタンス変数)
      - [2.7.7.1. インスタンス変数は`private`にします](#2771-インスタンス変数はprivateにします)
    - [2.7.8. クラス変数](#278-クラス変数)
      - [2.7.8.1. `public static final`宣言した配列を利用を禁止します](#2781-public-static-final宣言した配列を利用を禁止します)
      - [2.7.8.2. クラス変数にはクラス名を使用してアクセスしてください](#2782-クラス変数にはクラス名を使用してアクセスしてください)
    - [2.7.9. ローカル変数](#279-ローカル変数)
      - [2.7.9.1. ローカル変数は利用する直前で宣言します](#2791-ローカル変数は利用する直前で宣言します)
      - [2.7.9.2. ローカル変数は安易に再利用してはいけません](#2792-ローカル変数は安易に再利用してはいけません)
    - [2.7.10. 引数](#2710-引数)
      - [2.7.10.1. メソッド引数への代入を禁止します](#27101-メソッド引数への代入を禁止します)
    - [2.7.11. 継承](#2711-継承)
      - [2.7.11.1. スーパークラスのインスタンス変数をサブクラスでオーバーライドを禁止します](#27111-スーパークラスのインスタンス変数をサブクラスでオーバーライドを禁止します)
      - [2.7.11.2. スーパークラスのメソッドをオーバーライドするときは@Overrideアノテーションを指定します](#27112-スーパークラスのメソッドをオーバーライドするときはoverrideアノテーションを指定します)
      - [2.7.11.3. スーパークラスで`private`宣言されているメソッドと同じ名前のメソッドをサブクラスで定義することを禁止します](#27113-スーパークラスでprivate宣言されているメソッドと同じ名前のメソッドをサブクラスで定義することを禁止します)
    - [2.7.12. インナークラス](#2712-インナークラス)
      - [2.7.12.1. 原則としてインナークラスは利用はしないでください](#27121-原則としてインナークラスは利用はしないでください)
    - [2.7.13. メンバー順序](#2713-メンバー順序)
    - [2.7.14. インスタンス](#2714-インスタンス)
      - [2.7.14.1. オブジェクト同士は`equals()`メソッドで比較します](#27141-オブジェクト同士はequalsメソッドで比較します)
      - [2.7.14.2. Class名を利用した比較を禁止します](#27142-class名を利用した比較を禁止します)
      - [2.7.14.3. インスタンスの型キャスト（Classキャスト）が必要な場合はパターンマッチングを使用して下さい](#27143-インスタンスの型キャストclassキャストが必要な場合はパターンマッチングを使用して下さい)
    - [2.7.15. 制御構造](#2715-制御構造)
      - [2.7.15.1. 制御文（`if`, `else`, `while`, `for`, `do while`）の `{ }` は省略を禁止します](#27151-制御文if-else-while-for-do-whileの---は省略を禁止します)
      - [2.7.15.2. ステートメントがない`{}`ブロックの利用を禁止します](#27152-ステートメントがないブロックの利用を禁止します)
      - [2.7.15.3. `if`/`while`の条件式で`=`の利用を禁止します](#27153-ifwhileの条件式での利用を禁止します)
      - [2.7.15.4. `for`と`while` の使い分けを意識してください](#27154-forとwhile-の使い分けを意識してください)
      - [2.7.15.5. for文を利用した繰り返し処理中でループ変数の値の変更を禁止します](#27155-for文を利用した繰り返し処理中でループ変数の値の変更を禁止します)
      - [2.7.15.6. ノーマルfor文のカウンタは特別な事情がない限り、0から始めて下さい](#27156-ノーマルfor文のカウンタは特別な事情がない限り0から始めて下さい)
      - [2.7.15.7. 配列やリストなどの全要素に対するループ処理は拡張for文を使用して下さい](#27157-配列やリストなどの全要素に対するループ処理は拡張for文を使用して下さい)
      - [2.7.15.8. 反復処理中に反復処理の条件となるList、配列の変更を禁止します](#27158-反復処理中に反復処理の条件となるlist配列の変更を禁止します)
      - [2.7.15.9. 配列をコピーするときは`Arrays.copyOf()`メソッドを利用して下さい](#27159-配列をコピーするときはarrayscopyofメソッドを利用して下さい)
      - [2.7.15.10. 繰り返し処理中のオブジェクトの生成は最小限にして下さい](#271510-繰り返し処理中のオブジェクトの生成は最小限にして下さい)
      - [2.7.15.11. if文とelse文の繰り返しやswitch文の利用はなるべく避け、オブジェクト指向の手法を利用して下さい](#271511-if文とelse文の繰り返しやswitch文の利用はなるべく避けオブジェクト指向の手法を利用して下さい)
      - [2.7.15.12. 繰り返し処理の内部で `try` ブロックを禁止します](#271512-繰り返し処理の内部で-try-ブロックを禁止します)
    - [2.7.16. 文字列操作](#2716-文字列操作)
      - [2.7.16.1. 文字列同士が同じ値かを比較するときは、`equals()`メソッドを利用します](#27161-文字列同士が同じ値かを比較するときはequalsメソッドを利用します)
      - [2.7.16.2. 文字列リテラルは`new` しない](#27162-文字列リテラルはnew-しない)
      - [2.7.16.3. 更新される文字列には`StringBuilder` クラスを利用して下さい](#27163-更新される文字列にはstringbuilder-クラスを利用して下さい)
      - [2.7.16.4. １ステートメントのみで行われる文字列の連結には`+`演算子を利用する](#27164-１ステートメントのみで行われる文字列の連結には演算子を利用する)
      - [2.7.16.5. 更新されない文字列には`String`クラスを利用します](#27165-更新されない文字列にはstringクラスを利用します)
      - [2.7.16.6. 文字列リテラルと定数を比較するときは、文字列リテラルの`equals()`メソッドを利用します](#27166-文字列リテラルと定数を比較するときは文字列リテラルのequalsメソッドを利用します)
      - [2.7.16.7. プリミティブ型と`String` オブジェクトの変換には、変換用のメソッドを利用します](#27167-プリミティブ型とstring-オブジェクトの変換には変換用のメソッドを利用します)
      - [2.7.16.8. 文字列の中に、ある文字が含まれているか調べるには、`contains()`メソッドを利用します](#27168-文字列の中にある文字が含まれているか調べるにはcontainsメソッドを利用します)
      - [2.7.16.9. システム依存記号（`\n`、`\r`など）は使用を禁止します](#27169-システム依存記号nrなどは使用を禁止します)
    - [2.7.17. 数値](#2717-数値)
      - [2.7.17.1. 誤差のない計算をするときは、`BigDecimal` クラスを使用します](#27171-誤差のない計算をするときはbigdecimal-クラスを使用します)
      - [2.7.17.2. 数値の比較は精度に気をつけてください](#27172-数値の比較は精度に気をつけてください)
      - [2.7.17.3. 低精度なプリミティブ型にキャストを強く推奨しません](#27173-低精度なプリミティブ型にキャストを強く推奨しません)
      - [2.7.17.4. `BigDecimal`を`String`変換する際は`toString()`ではなく`toPlainString()`を利用してください](#27174-bigdecimalをstring変換する際はtostringではなくtoplainstringを利用してください)
    - [2.7.18. 日付](#2718-日付)
      - [2.7.18.1. 日付の文字列のフォーマットには、`SimpleDateFormat`または`DateTimeFormatter`を利用してください](#27181-日付の文字列のフォーマットにはsimpledateformatまたはdatetimeformatterを利用してください)
    - [2.7.19. 三項演算子](#2719-三項演算子)
      - [2.7.19.1. 入れ子の三項演算子の利用は禁止します](#27191-入れ子の三項演算子の利用は禁止します)
    - [2.7.20. switch式](#2720-switch式)
      - [2.7.20.1. ひとつの値を変数に代入するための if-else 文は代わりに switch 式の使用を推奨します](#27201-ひとつの値を変数に代入するための-if-else-文は代わりに-switch-式の使用を推奨します)
      - [2.7.20.2. case句はなるべくひとつの式での記述を推奨します](#27202-case句はなるべくひとつの式での記述を推奨します)
      - [2.7.20.3. switch 式は、コーディングミスによるフォールスルーを避けるため、常にアロー構文を使用します](#27203-switch-式はコーディングミスによるフォールスルーを避けるため常にアロー構文を使用します)
      - [2.7.20.4. アロー構文の、中カッコ、`yield`を省略できる場合は必ず省略してください](#27204-アロー構文の中カッコyieldを省略できる場合は必ず省略してください)
      - [2.7.20.5. Enum値のswitch式でcase句がすべてのEnum値をカバーする場合はdefault句はデッドコードとなるため記述は不要です](#27205-enum値のswitch式でcase句がすべてのenum値をカバーする場合はdefault句はデッドコードとなるため記述は不要です)
    - [2.7.21. switch 文](#2721-switch-文)
      - [2.7.21.1. 代わりにswitch式が使用できる箇所はswitch式を使用します](#27211-代わりにswitch式が使用できる箇所はswitch式を使用します)
      - [2.7.21.2. case 句はなるべく 1 行のステートメントでの記述を推奨します](#27212-case-句はなるべく-1-行のステートメントでの記述を推奨します)
      - [2.7.21.3. switch 文は、コーディングミスによるフォールスルーを避けるため、なるべくアロー構文を使用することを推奨します](#27213-switch-文はコーディングミスによるフォールスルーを避けるためなるべくアロー構文を使用することを推奨します)
      - [2.7.21.4. アロー構文を使用しない（コロンを使用する）場合、複数の値をマッチさせるときの case 句はカンマを使用して列挙してください](#27214-アロー構文を使用しないコロンを使用する場合複数の値をマッチさせるときの-case-句はカンマを使用して列挙してください)
    - [2.7.22. コレクション](#2722-コレクション)
      - [2.7.22.1. Java2 以降のコレクションクラスを利用します](#27221-java2-以降のコレクションクラスを利用します)
      - [2.7.22.2. 特定の型のオブジェクトだけを受け入れるコレクションクラスを利用します](#27222-特定の型のオブジェクトだけを受け入れるコレクションクラスを利用します)
      - [2.7.22.3. `List`のソートは`List.sort()`を利用する](#27223-listのソートはlistsortを利用する)
      - [2.7.22.4. `Collection.forEach()`は利用しない。拡張for文の利用を検討してください](#27224-collectionforeachは利用しない拡張for文の利用を検討してください)
      - [2.7.22.5. `Arrays.asList()`は利用せず、`List.of()`を利用します](#27225-arraysaslistは利用せずlistofを利用します)
      - [2.7.22.6. `Arrays.asList()`と`List.of()`の違い](#27226-arraysaslistとlistofの違い)
    - [2.7.23. ラムダ式・メソッド参照・コンストラクタ参照](#2723-ラムダ式メソッド参照コンストラクタ参照)
      - [2.7.23.1. ラムダ式が利用できる箇所はラムダ式を利用してよいです](#27231-ラムダ式が利用できる箇所はラムダ式を利用してよいです)
      - [2.7.23.2. メソッド参照・コンストラクタ参照が利用できる場合はメソッド参照・コンストラクタ参照を利用します](#27232-メソッド参照コンストラクタ参照が利用できる場合はメソッド参照コンストラクタ参照を利用します)
      - [2.7.23.3. ラムダ式記述の際、型宣言は省略記法で記述します](#27233-ラムダ式記述の際型宣言は省略記法で記述します)
      - [2.7.23.4. 原則ラムダ式内の行数は1行とします](#27234-原則ラムダ式内の行数は1行とします)
      - [2.7.23.5. 原則ラムダ式は 1 行記述に限定するので、中カッコ、`return`は必ず省略します](#27235-原則ラムダ式は-1-行記述に限定するので中カッコreturnは必ず省略します)
    - [2.7.24. Stream API](#2724-stream-api)
      - [2.7.24.1. 並列ストリームは利用を原則禁止します](#27241-並列ストリームは利用を原則禁止します)
      - [2.7.24.2. 中間処理の数は 3 つ（3 行）程度までを推奨します](#27242-中間処理の数は-3-つ3-行程度までを推奨します)
      - [2.7.24.3. コメントは、原則として処理中には記載してはいけません](#27243-コメントは原則として処理中には記載してはいけません)
      - [2.7.24.4. Stream は極力変数代入しないようにしてください](#27244-stream-は極力変数代入しないようにしてください)
    - [2.7.25. Optional](#2725-optional)
      - [2.7.25.1. Optional は同メソッド内で値を取り出す場合は極力変数代入しないこと](#27251-optional-は同メソッド内で値を取り出す場合は極力変数代入しないこと)
    - [2.7.26. var（Local-Variable Type Inference）](#2726-varlocal-variable-type-inference)
      - [2.7.26.1. 明確な方針で、利用する・利用しないを統一してください](#27261-明確な方針で利用する利用しないを統一してください)
      - [2.7.26.2. 右辺で、明確に型が分かる場合は`var`を利用する場合](#27262-右辺で明確に型が分かる場合はvarを利用する場合)
    - [2.7.27. レコード・クラス](#2727-レコードクラス)
      - [2.7.27.1. 明確な方針で、利用する・利用しないを統一してください](#27271-明確な方針で利用する利用しないを統一してください)
      - [2.7.27.2. 次の記述スタイルを標準としてください](#27272-次の記述スタイルを標準としてください)
      - [2.7.27.3. レコードのアクセサの上書きを禁止します](#27273-レコードのアクセサの上書きを禁止します)
    - [2.7.28. テキストブロック](#2728-テキストブロック)
      - [2.7.28.1. 複数行の文字列を定義する際、文字列連結よりもテキストブロックを使用します](#27281-複数行の文字列を定義する際文字列連結よりもテキストブロックを使用します)
      - [2.7.28.2. 単一行の文字列を定義する際、テキストブロックは使用せず文字列リテラルを使用します](#27282-単一行の文字列を定義する際テキストブロックは使用せず文字列リテラルを使用します)
      - [2.7.28.3. テキストブロック内では基本的に改行コードのエスケープシーケンス(`\n`)を使用しないが、読みやすさ向上の目的で改行コードのエスケープシーケンス(`\n`)を使用してもよいです](#27283-テキストブロック内では基本的に改行コードのエスケープシーケンスnを使用しないが読みやすさ向上の目的で改行コードのエスケープシーケンスnを使用してもよいです)
      - [2.7.28.4. テキストブロックで定義した文字列を処理する場合は、テキストブロックをローカル変数やフィールドへ代入してから使用することを推奨します](#27284-テキストブロックで定義した文字列を処理する場合はテキストブロックをローカル変数やフィールドへ代入してから使用することを推奨します)
      - [2.7.28.5. つ以上続く二重引用符(`"`)をエスケープする際は、最初の二重引用符にエスケープシーケンスを使用します](#27285-つ以上続く二重引用符をエスケープする際は最初の二重引用符にエスケープシーケンスを使用します)
      - [2.7.28.6. テキストブロックの開始引用符(`"""`)は前の行の右端に記述します](#27286-テキストブロックの開始引用符は前の行の右端に記述します)
      - [2.7.28.7. テキストブロックのインデントは開始引用符(`"""`)に合わせる必要はありません](#27287-テキストブロックのインデントは開始引用符に合わせる必要はありません)
      - [2.7.28.8. テキストブロックで定義する文字列のインデントは基本的に周辺のJava コードに合わせてインデントします](#27288-テキストブロックで定義する文字列のインデントは基本的に周辺のjava-コードに合わせてインデントします)
      - [2.7.28.9. テキストブロックのインデントにスペース文字とタブ文字を混在を禁止します](#27289-テキストブロックのインデントにスペース文字とタブ文字を混在を禁止します)
      - [2.7.28.10. 文字列の最後に改行コードを入れずに、意図的にインデントした文字列を定義するとき終了引用符(`"""`)の前の行の右端に`\`を使用します](#272810-文字列の最後に改行コードを入れずに意図的にインデントした文字列を定義するとき終了引用符の前の行の右端にを使用します)
    - [2.7.29. ストリーム（InputStream OutputStream）](#2729-ストリームinputstream-outputstream)
      - [2.7.29.1. ストリームを扱う API を利用するときは、try-with-resources 文で後処理をします](#27291-ストリームを扱う-api-を利用するときはtry-with-resources-文で後処理をします)
      - [2.7.29.2. `ObjectOutputStream` では`reset()`を利用します](#27292-objectoutputstream-ではresetを利用します)
    - [2.7.30. リソースの解放](#2730-リソースの解放)
      - [2.7.30.1. リソース解放を必要とするクラスを利用するときは、try-with-resources 文で後処理をします](#27301-リソース解放を必要とするクラスを利用するときはtry-with-resources-文で後処理をします)
      - [2.7.30.2. リソース解放を必要とするクラスを作成する場合は`AutoCloseable`を`implements`します](#27302-リソース解放を必要とするクラスを作成する場合はautocloseableをimplementsします)
    - [2.7.31. 例外](#2731-例外)
      - [2.7.31.1. catch 文で受け取る例外は、詳細な例外クラスで受け取リます](#27311-catch-文で受け取る例外は詳細な例外クラスで受け取リます)
      - [2.7.31.2. `Exception` クラスのオブジェクトを生成してスローしてはいけません](#27312-exception-クラスのオブジェクトを生成してスローしてはいけません)
      - [2.7.31.3. `catch` ブロックでは基本、例外処理をする。ただし処理を書いてはいけない部分もあるので、その部分については、"`// ignore`" というコメントを記述してください](#27313-catch-ブロックでは基本例外処理をするただし処理を書いてはいけない部分もあるのでその部分については-ignore-というコメントを記述してください)
      - [2.7.31.4. 例外クラスを勝手に定義することは禁止します](#27314-例外クラスを勝手に定義することは禁止します)
    - [2.7.32. ガベージコレクション](#2732-ガベージコレクション)
      - [2.7.32.1. 原則`finalize()`のオーバーライド実装は禁止します](#27321-原則finalizeのオーバーライド実装は禁止します)
  - [2.8. 注意事項](#28-注意事項)
    - [2.8.1. メソッドには名前から想像できない処理を実装しないでください](#281-メソッドには名前から想像できない処理を実装しないでください)
    - [2.8.2. 単一のメソッドに複数の要素を詰め込まないでください](#282-単一のメソッドに複数の要素を詰め込まないでください)
    - [2.8.3. クラス外に公開されるメソッドの引数や戻り値・フィールドの型は実装クラスではなくインターフェースで宣言してください](#283-クラス外に公開されるメソッドの引数や戻り値フィールドの型は実装クラスではなくインターフェースで宣言してください)
    - [2.8.4. メソッドのオーバーロードはオプションの省略用途のみに使用してください](#284-メソッドのオーバーロードはオプションの省略用途のみに使用してください)
    - [2.8.5. 未使用コードは残したままにしないでください](#285-未使用コードは残したままにしないでください)
    - [2.8.6. クラスは大きくなりすぎないようにしてください](#286-クラスは大きくなりすぎないようにしてください)
    - [2.8.7. メソッドは大きくなりすぎないようにしてください](#287-メソッドは大きくなりすぎないようにしてください)
    - [2.8.8. インナークラスやstaticにネストしたクラス、匿名クラスは作りすぎないようにしてください](#288-インナークラスやstaticにネストしたクラス匿名クラスは作りすぎないようにしてください)
    - [2.8.9. 可能な限りキャストは使用しないでください](#289-可能な限りキャストは使用しないでください)
    - [2.8.10. ラッパークラスの変数とプリミティブ値を演算する際は、アンボクシングに注意してください](#2810-ラッパークラスの変数とプリミティブ値を演算する際はアンボクシングに注意してください)
    - [2.8.11. 計算の誤差が許されない場合はBigDecimalを使用してください](#2811-計算の誤差が許されない場合はbigdecimalを使用してください)
    - [2.8.12. ソートと集計はJava側ではなく、SQLで行うようにしてください](#2812-ソートと集計はjava側ではなくsqlで行うようにしてください)
    - [2.8.13. ループ処理の中では極力データベースアクセスしないようにしてください](#2813-ループ処理の中では極力データベースアクセスしないようにしてください)
    - [2.8.14. 外部からの入力値は共通部品を用いてチェックしてください](#2814-外部からの入力値は共通部品を用いてチェックしてください)
    - [2.8.15. ファイル入出力は共通部品のクラスを使用してください](#2815-ファイル入出力は共通部品のクラスを使用してください)
    - [2.8.16. リソースをクローズする必要がある場合はtry-with-resources構文を使用してください](#2816-リソースをクローズする必要がある場合はtry-with-resources構文を使用してください)
    - [2.8.17. 例外処理はプロジェクトの方式設計にしたがって統一的にコーディングしてください](#2817-例外処理はプロジェクトの方式設計にしたがって統一的にコーディングしてください)
    - [2.8.18. ループのネストはできれば二重までにしてください](#2818-ループのネストはできれば二重までにしてください)

## 2.1. パッケージ構成

### 2.1.1. 方式設計上の適した形にしたがってパッケージを構成してください

業務アプリケーションでは方式設計上にしたがってパッケージを構成してください。
ここでいう適した構成とは、教育コストのかからないパッケージ構成と今後の開発の柔軟さを天秤にかけたバランスのことを指します。

パッケージ名の簡単な例を示します。

|役割|命名例|
|---|---|
|アクション|`com.example.action`|
|エンティティ|`com.example.entity`|
|業務フォーム|`com.example.form`|
|バリデーター|`com.example.validation`|
|DTO|`com.example.dto`|
|コントローラ|`com.example.controller`|
|サービス|`com.example.service`|
|ビジネスロジック|`com.example.bizlogic`|
|リポジトリ|`com.example.repository`|

---

## 2.2. ソースファイルの基本事項

### 2.2.1. ファイルエンコーディング

ソースファイルは**UTF-8**でエンコードされている必要があります。

### 2.2.2. 特殊文字

特別なエスケープシーケンスをもつすべての文字については8進数表記やUnicodeエスケープでなく、通常のエスケープシーケンスで表記します。

```text
// 特殊なエスケープシーケンスを持つ文字
(\b, \t, \n, \f, \r, \", \' , \\)
```

残りの非ASCII文字については実際のUnicode文字（例：∞）あるいは同等のUnicodeエスケープ（例：\u221e）が使われます。
これは、**ソースコードを読むことや理解することが簡単になる**かどうかのみに依存します。文字列リテラルやコメント以外でのUnicodeエスケープは強く推奨しません。

```java
//Bad 値に何が入るか不明のためNG。
String unitAbbrev = "\u03bcs";
```

```java
//Good コメントがなくても値がわかるため最良。
String unitAbbrev = "μs";
//Good コメントで内容を書いているため許容される。しかしこう書く理由はない。
String unitAbbrev = "\u03bcs"; // "μs"
```

### 2.2.3. ソースファイル構造

ソースファイルの内容は次の順序です。

1. ライセンスあるいはコピーライトの情報（任意）
2. package文
3. import文
4. ファイル名と同一のクラス名

ソースに書かれている内容それぞれの分離には**1行の空行**を挿入します。

---

## 2.3. 全般

### 2.3.1. 原則としてオブジェクトの参照にはインターフェースを利用します

オブジェクトを参照する際は、そのオブジェクトの実装クラスを用いて宣言できますが、実装クラスに適切なインターフェースが存在している場合は、必ずインターフェースを用いて宣言してください。

```java
//Bad
ArrayList<Entry> list = new ArrayList<>();
HashMap<String, String> map = new HashMap<>();
```

```java
List<Entry> list = new ArrayList<>();
Map<String, String> map = new HashMap<>();
```

### 2.3.2. DeprecatedされたAPIの使用を禁止します

アノテーション`@Deprecated`で指定されたメソッドの利用を禁止します。

### 2.3.3. アクセス修飾子は適切な権限で宣言してください

`public`、`protected`、`private`の指定は適切に指定してください。

`private`で宣言するものは、他クラスで共通化できないか考慮してください。

### 2.3.4. finalを利用することを推奨します

継承されないクラスやオーバーライドされたくないメソッド、再代入されない変数等、変化のないもの／変化させたくないものについては`final`で宣言することを推奨します。

`final`を使わない場合でも、変数の再代入は原則行わないでください。

```java
//継承されないクラス
public final class CalculateUtils {
    //・・・
}

//値の変わらない変数（定数）
private static final String MESSAGE = "・・・";

//オーバーライドされないメソッド
public final int sum(/*変化させたくない値*/final int... values) {
    int sumValue = 0;
    for (/*変化させたくない値*/final int value : values) {
        sumValue += value;
    }
    return sumValue;
}
```

### 2.3.5. if文などの条件式でbooleanと比較しないでください

```java
//Bad
if (hasStock == true) {
    ...
}
```

```java
if (hasStock) {
    ...
}
```

---

## 2.4. 命名

クラスやメソッド、変数の命名についての規約です。

すべての命名はASCII文字、数字のみで構成してください。

単語の区切りの最初の文字を大文字にするキャメルケース、クラス名ではアッパーキャメルで記載してください。
例）camel case = camelCase

変数名は単語を省略せず、誰でも分かる命名をしてください。

```java
//Bad 変数名から変数の値が何を意味しているのかが不明のためNG。
private int value = 10;
private boolean flag = false;
private static final String DB_STR_50 = "50";
private static final String DB_STR_50_NM = "消費税";
```

```java
//Good 変数の意味が理解できる命名。
private int consumptionTax = 10;
private boolean isDialogOpen = false;
private static final String CONSUMPTION_TAX_CODE = "50";
private static final String CONSUMPTION_TAX_NAME = "消費税";

//Good 税の値を一つのclassやenumにまとめて意味を理解しやすくする
public Enum TaxCategory {
    .
    .
    .
    CONSUMPTION("50", "消費税");

    private String code;
    private String codeName;
    .
    .
    .
}
```

### 2.4.1. クラス名は基本的には名詞とし、必要に応じて方式設計上の規則にしたがって命名してください

クラス名は基本的には名詞で大文字始まりにします。

```java
//Bad クラス名が小文字始まりのためNG。
public class entry {
    ...
}
```

```java
//Good クラス名が大文字始まりで記載している。
public class Entry {
    ...
}
```

慣習的に「特定の能力を付与することを表すインターフェース」は、末尾に`able`を付けることがあります。
Java標準APIにもそのような名前のインターフェースがいくつも含まれています。

- `java.lang.Appendable`
- `java.lang.AutoCloseable`
- `java.lang.Comparable`
- `java.lang.Iterable`
- `java.lang.Runnable`

業務アプリケーションで作成するクラスは方式設計上の認識に従った役割を持っていることが多いです。
そのため、認識に対応していることが分かるような接尾語を付けるなどして命名をしてください。

|役割|命名ルール|
|---|---|
|アクション|機能を表す名前 + `Action`|
|エンティティ|テーブルの物理名をアッパーキャメルケースにしたもの|
|業務ベースフォーム|機能を表す名前 + `FormBase`|
|業務フォーム|機能を表す名前 + `Form`|
|バリデーター|機能を表す名前 + `Validator`|
|DTO|データの種類を表す名前 + `Dto`|
|排他制御の制御クラス|テーブルの物理名をアッパーキャメルケースにしたもの + `ExclusiveControl`|
|テスト|テスト対象クラス名 + `Test`|
|リクエスト単体テスト|`Action`クラス名 + `RequestTest`|

### 2.4.2. メソッド名は基本的には動詞から始まるように命名をしてください

メソッド名は動詞から始まるように命名をするのが基本になりますが、次に示す「機能別の推奨命名ルール」には動詞から始まらないものも含んでいます。

コンストラクタと同じ名前のメソッドの作成を禁止します。

|機能|命名ルール|例|
|---|---|---|
|インスタンスを生成する|`create` + 対象|`createItemCode`|
|異なる型に変換する|`to` + 変換先の型|`toString` `toItemCode`|
|異なる型として扱う|`as` + 扱う型|`asReadLock` `asList`|
|含んでいるかどうかを返す|`contains` + 対象|`containsKey`|
|可能かどうかを返す|`can` + 動作|`canRead` `canEncode`|
|その状態かどうかを返す|`is` + 状態|`isClosed` `isEmpty`|

「異なる型に変換する」と「異なる型として扱う」は同じように見えますが、少し異なります。
前者は「異なる型に変換してしまって元の型の性質は期待しない」のに対して、後者は「異なる型に変換するが元の型の性質と関連する」ものです。
Java標準APIでいうと、前者にあたるのは`Integer.toString`です。整数が文字列に変換されて、整数の性質は期待されません。
後者にあたるのは`Arrays.asList`です。配列がリストに変換されますが、配列とリストは性質が似ていますし、元の配列を変更するとリストも変更されます。

Java標準APIを見ても`String.length`や`Optional.of`のように動詞から始まらない名前のメソッドがいくつも存在します。
Java標準APIも参考にして、適切な命名を行うようにしてください。

### 2.4.3. 変数は基本的には名詞で命名してください

フィールド名やローカル変数名、メソッド引数は基本的には名詞にします。

Javaの命名規則の慣習上、決まった名前を付ける場合があります。

`java.io.InputStream`や`java.io.OutputStream`は、それぞれ `in` `is` や `out` `os`と命名しても構いません。

変数は原則として、`final`で宣言します。

これは宣言した場所以外で再代入を行っていないことを明示し、可読性向上につながります。

```java
try (final InputStream in = openInputStream(file)) {
    ...
}
```

ノーマル`for`文で使用するカウンターは`i`と命名することが一般的です。

```java
for (int i = 0; i < length; i++) {
    ...
}
```

`catch`ブロックで例外を受け取る変数は`e`と命名することが一般的です。

また、値を組み立てるために一時的に使用されるスコープの狭い変数は意味のない名前でも構いません。

```java
//メッセージを組み立てるための一時変数
//ここではbufという無意味な名前を付けている
//sbやtempといった名前でもよい
final StringBuilder buf = new StringBuilder();
buf.append("Hello, ");
buf.append(yourName);
buf.append("!");
final String message = buf.toString();
```

メソッド引数は再代入しないことを強く推奨します。

再代入が行われると、可読性の著しい低下を招きます。

```java
public static BigDecimal calculateLatePaymentCharge(final BigDecimal borrowedAmount, final int numberOfDays) {
    ...
} 
```

### 2.4.4. データモデルの用語辞書を活用して命名してください

整理された用語辞書をもとにすると、統一感のある命名ができます。

是非、用語辞書を活用してください。
用語辞書が整理されていない場合は、まず用語辞書の整理をすることを検討してみてください。

---


---

## 2.6. 禁止事項

バグを発生させる危ういコードを減らすため、禁止事項を定めています。

### 2.6.1. 計算式の途中でインクリメント・デクリメントをしないでください

計算式の途中でインクリメント・デクリメントをすると、該当の変数の値が分かりにくくなります。

計算式は計算のみを実施し、インクリメント・デクリメントは別途行うようにしてください。

```java
//Bad
int x = ...
//計算後にxがインクリメントされ可読性低下
int y = (x++ * height) / width;
```

```java
//Good
int x = ...
int y = (x * height) / width;
x++;
```

### 2.6.2. フィールド（メンバー変数）を一時変数として使用しないでください

コレクションの要素を順次処理して必要な値を構築するメソッドなどで中間状態を保持するために一時変数を導入することがありますが、その場合にフィールドを使用しないでください。

フィールドを使用するとクラスがもつ状態を増やすことになります。

なるべく変更可能な状態は持たないようにするためにも、一時変数の用途でフィールドは使用しないでください。

特にSpring FrameworkをはじめとしたDIを行うものは、シングルトンの構造になっているため、フィールドの情報がスレッドで共有されます（所謂スレッドアンセーフ）。

思わぬバグに繋がるため、一時変数の用途にはフィールドではなく、ローカル変数を使用してください。

```java
//Bad
//フィールドを一時変数として使用している
private List<String> itemNames;

public String collectNames(final List<Item> items) {
    this.itemNames = new ArrayList<>();
    for (Item item : items) {
        collectName(item);
    }
    return this.itemNames.stream().collect(Collectors.joining(", "));
}

private void collectName(final Item item) {
    this.itemNames.add(item.getName());
}
```

```java
//Good
public String collectNames(final List<Item> items) {
    //一時変数はローカル変数を使用して、メソッドに渡して引き回している
    final List<String> itemNames = new ArrayList<>();
    for (Item item : items) {
        collectName(itemNames, item);
    }
    return itemNames.stream().collect(Collectors.joining(", "));
}

private void collectName(final List<String> itemNames, final Item item) {
    itemNames.add(item.getName());
}
```

### 2.6.3. スーパークラスと同名のフィールドをサブクラスで定義しないでください

スーパークラスに定義されているフィールドと同名のフィールドをサブクラスにも定義すると、スーパークラスに定義されているフィールドを名前だけでアクセスできなくなります。

フィールドはメソッドと異なりオーバーライドできません。

混乱の元となるので、スーパークラスと同名のフィールドをサブクラスで定義しないでください。

```java
//Bad
public class SuperClass {

    //サブクラスで使用されることが想定されているフィールド
    protected final String str;

    ...
}

public class SubClass extends SuperClass {

    private final String str;

    public String getStr() {
        return str; //SubClass.str が返される
    }

    ...
}
```

### 2.6.4. 戻り値がコレクションや配列の場合は null を返さないでください

値がない状態を表すために`null`を使うことがありますが、戻り値が次に示すようなコレクションや配列の場合は値がない状態を表すためであっても`null`を返さないでください。

- `java.util.Collection`
- `java.util.Set`
- `java.util.List`
- `java.util.Map`

コレクションの値がない状態というのは、多くの場合はコレクションが空であることを指します。
コレクションには空であることを示す`isEmpty`というメソッドがあるので、わざわざ`null`を返す必要はありません。
また、配列の場合は`length`フィールドが`0`なら空であると判断できます。

`null`を返す可能性があると、呼び出し元で`null`チェックをしなくてはならずコードが複雑になります。

```java
//Bad
public List<Item> findItems(final ItemCategory category) {
    List<Item> items = dao.findItems(category);
    if (items.isEmpty()) {
        return null;
    }
    return items;
}
```

```java
//Good
public List<Item> findItems(final ItemCategory category) {
    return dao.findItems(category);
}
```

明示的に空のコレクションを作成して返したい場合は`java.util.Collections`クラスにある`empty<コレクション>`メソッドを使用してください。

たとえば条件に応じて空のリストを返したい場合は`java.util.ArrayList`をインスタンス化するのではなく、`java.util.Collections`クラスの`emptyList`メソッドを使用してください。

```java
//Bad
if (empty) {
    return new ArrayList<>();
}
```

```java
//Good
if (empty) {
    return Collections.emptyList();
}
```

`java.util.Collections`には`emptyList`以外にもコレクションの種類に応じて`emptySet`や`emptyMap`が用意されています。

### 2.6.5. コンストラクタ内で自分自身のインスタンスメソッドを呼び出さないようにしてください

コンストラクタ内では、たとえ`final`が付いているフィールドであっても初期化前の`null`値を参照してしまう場合があります。

そのため、コンストラクタからフィールドを参照するインスタンスメソッドを呼び出す場合、フィールドの初期化とメソッドの呼び出しの順番に注意する必要が出てきてしまいます。

```java
//Bad
public class Foo {

    private final String text;
    private final int length;

    public Foo(final String text) {

        //textが初期化されていないのでこの位置でcalculateLengthを呼び出すと
        //NullPointerExceptionがスローされる。
        this.length = calculateLength();

        this.text = text;

        //textが初期化された後のこの位置で呼び出すべき。
        //this.length = calculateLength();
    }

    protected int calculateLength() {
        return text.length();
    }
}
```

継承を伴うと話はさらに複雑化します。

次に示すNG例を見てください。
`Foo`と`Bar`という2つのクラスが定義されています。
`Bar`は`Foo`を継承しています。

`Bar`をインスタンス化すると、`Bar`のコンストラクタの先頭で`Foo`のコンストラクタが呼び出されます。
`Foo`のコンストラクタでは`calculateLength`を呼び出そうとしますが、`Bar`でオーバーライドされているので実際には`Bar`の`calculateLength`が呼び出されます。
`Bar`の`calculateLength`では`text`を参照していますが、この時点ではまだ初期化されていないので`NullPointerException`となってしまいます。

```java
//Bad
public class Foo {

    private final int length;

    public Foo() {
        //コンストラクタで自分自分のメソッドを呼び出している
        this.length = calculateLength();
    }

    protected int calculateLength() {
        return 0;
    }
}

class Bar extends Foo {

    protected final String text;

    public Bar(final String text) {
        this.text = text;
    }

    @Override
    protected int calculateLength() {
        //ここでNullPointerExceptionがスローされる
        return text.length();
    }
}
```

このような複雑さを持ち込んでしまうため、コンストラクタ内から自分自身のインスタンスメソッドを呼び出さないようにしてください。

コンストラクタ内では基本的には引数をフィールドにセットするだけにしてください。
何かしらの処理を行いたい場合は、コンストラクタ内で処理を完結させるようにしてください。

```java
//Good
public class Foo {

    private final String text;
    private final int length;

    public Foo(final String text) {
        this.text = text;
        // コンストラクタ内で処理が完結している
        this.length = text.length();
    }
}
```

ただし、コンストラクタ内で長々と処理を書く必要が出てきた場合は、次に挙げるように自クラス以外で処理する方法も含めて検討してください。

- コンストラクタを呼び出す前にあらかじめ処理を行い、その結果をコンストラクタの引数に渡す
- コンストラクタ内で別のクラスに処理を委譲し、その結果を使用する

### 2.6.6. インスタンスが格納された変数をレシーバにして`static`メソッドを呼び出さないでください

`static`メソッドは通常、クラス名をレシーバにして呼び出すコードを書きます。

インスタンスが格納された変数をレシーバにして呼び出すコードも文法的には許容されていますが、一般的ではないため行わないでください。

```java
//Bad
final String text = ...
final int value = ...
return text.valueOf(value);
```

```java
//Good
final int value = ...
return String.valueOf(value);
```

### 2.6.7. インスタンスが格納された変数をレシーバにして`static`変数を参照しないでください

`static`変数は通常、クラス名をレシーバにして参照するコードを書きます。

インスタンスが格納された変数をレシーバにして参照コードも文法的には許容されていますが、一般的ではないため行わないでください。

```java
//Bad
final Integer length = ...
return length.MAX_VALUE;
```

```java
//Good
return Integer.MAX_VALUE;
```

### 2.6.8. アプリケーションプログラマーの独断で例外クラスは作らないでください

例外はメソッドの処理を中断して大域脱出ができる仕組みです。
適切な管理の元、統一的に扱うべきだと考えます。

必要な例外クラスはフレームワークが提供するものとし、アプリケーションプログラマーは提供されたクラスを使用してください。

もし例外クラスの作成が必要になった場合は、プロジェクト責任者にプロジェクト全体で利用する例外クラスの追加を相談してください。

### 2.6.9. java.lang.Exceptionクラスのインスタンスを生成してスローしないでください

明示的に例外をスローする場合に単なる`java.lang.Exception`クラスのインスタンスを生成してスローしないでください。
業務アプリケーションの方式設計に沿った例外クラスのインスタンスを生成してスローしてください。

`java.lang.Exception`はすべての例外の基底クラスなので、`catch`する側が業務アプリケーションの例外なのかネットワークの例外なのかといった判別ができません。

また、`java.lang.Exception`をスローすると`throws Exception`をメソッドに付与しなければいけませんが、呼び出し元のメソッドにも`throws Exception`を強要することになり、扱いづらくなってしまいます。

```java
//Bad
if (items.isEmpty()) {
    throw new Exception("Items searched by " + code + " are not found.");
}
```

```java
//Good
if (items.isEmpty()) {
    throw new ItemsNotFoundException(code);
}
```

### 2.6.10. try-catch 文を条件分岐のために使用しないでください

`try-catch`文は例外を扱うためのものです。
条件分岐をしたい場合は`if`文を使用してください。

また例外がスローされた場合、`catch`できるかどうかをチェックしますが、このチェックは高コストです。
特にループ内で`try-catch`を条件分岐のために使用していた場合は、性能劣化が顕著に起る可能性があります。

```java
//Bad
try {
    //codeに対するitemがない場合に例外をスローするAPI
    service.findItem(code);
    return "Items exist";
} catch (ItemsNotFoundException e) {
    return "No items";
}
```

```java
//Good
//codeに対するitemが存在するかチェックするAPI
if (service.exists(code)) {
    return "Items exist";
} else {
    return "No items";
}
```

### 2.6.11. 秘匿情報はログ出力やシリアライズされないように注意してください

パスワードのような秘匿情報はログに含まれないようにマスクするなど、注意をしてください。

また、インスタンスをシリアライズする場合も、秘匿情報が含まれないように注意してください。
なお、ここでは「シリアライズ」という言葉の意味として、JavaのシリアライズのみならずJSONやXMLなどのフォーマットに変換することも含めています。

たとえばJavaのシリアライズの場合、シリアライズ対象外にしたいフィールドには`transient`キーワードを付与します。

```java
public class LoginForm implements Serializable {

    private String username;
    private transient String password;

    ...
}
```

JSONやXMLへのシリアライズでも、通常はライブラリがシリアライズ対象外にする方法を用意してありますので、適切に対応してください。

### 2.6.12. Java標準ライブラリにあるレガシーなAPIは使用しないでください

Java標準ライブラリには過去のバージョンでは使われていましたが、今となってはレガシーであり使うべきではないAPIがあります。
次に列挙するレガシーAPIは使わないようにしてください。

|レガシーAPI|代替となる使ってもよいAPI|
|---|---|
|`java.lang.StringBuffer`|`java.lang.StringBuilder`|
|`java.util.Dictionary`|`java.util.Map`|
|`java.util.Enumeration`|`java.util.Iterator`|
|`java.util.Hashtable`|`java.util.HashMap`|
|`java.util.Stack`|`java.util.Deque`|
|`java.util.StringTokenizer`|`String`の`split`メソッド、または`java.util.regex`パッケージのAPI|
|`java.util.Vector`|`java.util.ArrayList`|

これらのレガシーAPIを使用しているかどうかは`SonarQube`や`IntelliJ Idea`を始めとした使用不許可APIチェックツールによって検出できますが、知識として知っておくためにも本規約に明記しています。

### 2.6.13. リフレクションを直接使用しないでください

`java.lang.reflect`パッケージにあるクラスを使ってできる操作をリフレクションと言いますが、リフレクションを直接使用しないでください。
リフレクションを使用すると動的なオブジェクト操作ができますが「コンパイルは通っているけれど、実行時にエラーが出る」といった状況を引き起こす原因になります。

フレームワークやプロジェクトから提供される共通部品が内部でリフレクションを使用していることはありますが、アプリケーションで直接使用することは禁止します。

リフレクションを使用しているかどうかは使用不許可APIチェックツールによって検出できますが、危険なコードを書かないためにも本規約に明記しています。

### 2.6.14. クラスを不整合な状態にしないでください

クラス内に関連性のある複数のフィールドを定義した場合、それらのフィールド間で値の整合性を保つようにしてください。

```java
//Bad
public class ItemList {

    private final List<Item> items = new ArrayList<>();
    private BigDecimal totalPrice = BigDecimal.ZERO;

    public void add(final Item item) {
        //この時点で合計値が変わるためtotalPriceを更新しなければいけない
        items.add(item);
    }

    public void save(final ItemDao dao) {
        //保存時についでに合計値の計算をしている
        totalPrice = BigDecimal.ZERO;
        for (final Item item : items) {
            dao.save(item);
            totalPrice = totalPrice.add(item.getPrice());
        }
    }

    public BigDecimal getTotalPrice() {
        //addの後にsaveを呼ばずにこのメソッドを呼ぶとItem追加前の合計値が返されてしまう
        return totalPrice;
    }
}
```

上記の例では`items`を変更した際、同時に`totalPrice`を変更するとよいでしょう。

```java
//Good
public class ItemList {

    private final List<Item> items = new ArrayList<>();
    private BigDecimal totalPrice = BigDecimal.ZERO;

    public void add(final Item item) {
        //itemを追加してすぐに合計値の計算をしているので状態の整合性が保たれている
        items.add(item);
        totalPrice = totalPrice.add(item.getPrice());
    }

    public void save(final ItemDao dao) {
        for (final Item item : items) {
            dao.save(item);
        }
    }

    public BigDecimal getTotalPrice() {
        //どのタイミングで呼び出しても正しい合計値を返す
        return totalPrice;
    }
}
```

もしくは合計値は状態として持たずに`getTotalPrice`内で都度計算するようにしてもよいでしょう。

```java
//Good
public class ItemList {

    private final List<Item> items = new ArrayList<>();

    public void add(final Item item) {
        items.add(item);
    }

    public void save(final ItemDao dao) {
        for (final Item item : items) {
            dao.save(item);
        }
    }

    public BigDecimal getTotalPrice() {
        return items.stream()
                .map(item -> item.getPrice())
                .reduce(BigDecimal.ZERO, (price1, price2) -> price1.add(price2));
    }
}
```

### 2.6.15. アプリケーションプログラマーの独断でスレッドを作って非同期処理をしないでください

フレームワークはスレッドに紐付けてデータベースコネクションやトランザクションを管理していることがあります。
アプリケーションプログラマーが自分でスレッドを作って非同期処理を行うことは想定されていません。

また、フレームワークの制限がないとしても非同期処理は高難度です。
パフォーマンスなどの観点から非同期処理が必要になった場合は、プロジェクト責任者に相談してください。

<!-- ### 名前と値が同じ定数は作らないでください

定数の名前と値が同じになっているものは、もっとよい名前がある場合と、そもそも定数にしなくてよい場合があります。

次に示すのは、もっとよい名前がある例です。
定数名が改行コードの値そのものになっています。

```java
//Bad
//この名前だともし改行コードがLFに変更となった場合に定数名も変更しなくてはいけない
private static final String CRLF = "\r\n";
```

この場合は定数名を変えるとよいでしょう。

```java
//Good
//この名前だともし改行コードがLFに変更となった場合でも定数名はこのままでよい
private static final String LINE_BREAK = "\r\n";
```

次に示すのは、そもそも定数にしなくてよい例です。
あるテーブルのカラム名を定数にしたものです。

```java
//Bad
private static final String ITEM_CODE = "ITEM_CODE";
```

もしカラム名が変わるとそれに追随して定数名も変えることになり、定数化している意味が薄まります。
別の名前を付けるとしたら`COLUMN_01`といったものしか考えられず、意味ある名前にはなりません。

この場合は定数にしなくてよいでしょう。 -->

---

## 2.7. Java構文

### 2.7.1. インポート

#### 2.7.1.1. インポート文の順序

import文は次の順序です。

1. すべてのstatic importを単一のブロックでまとめる
2. すべての非static importを単一のブロックでまとめる
3. 各ブロック内のimportされた名前はASCII順序

#### 2.7.1.2. `java.lang`パッケージはインポートを禁止します

```java
//Bad
import java.lang.String;//必要のない記述
```

#### 2.7.1.3. staticインポートを禁止します

オンデマンド型インポート宣言はstatic importにかかわらず禁止します。

ただし、JUnitなどテストコードに関しては例外的に許可します。

例外として、JUnitの作成やフレームワークとしてstaticインポートが推奨されるような場合は利用してもよいです。

#### 2.7.1.4. オンデマンド型インポート宣言を禁止します

type-import-on-demand declaration（アスタリスク`*`によるインポート、ワイルドカードインポートとも呼ばれる）は禁止します。

```java
//Bad
import java.util.*;
```

### 2.7.2. コンストラクタ

#### 2.7.2.1. public宣言していないクラスには`public`権限のコンストラクタの作成を禁止します

```java
//Bad
class Entry {
    //・・・
    public Entry(int id) {
        //・・・
    }
```

```java
//Good
class Entry {
    //・・・
    Entry(int id) {
        //・・・
    }
```

#### 2.7.2.2. インスタンスメンバを持たない（staticメンバのみの）クラスは、`private`権限のコンストラクタを作成します

### 2.7.3. メソッド

#### 2.7.3.1. オーバーライドさせたくないメソッドは`final`を利用します

`final`を利用することで、オーバーライドを防ぐことができます。

一般的にクラス、メソッド共にオーバーライドする前提で定義することはないと思いますが、独自のガーベジコレクションを実装したクラスなど、特に禁止する場合は`final`を利用してください。

#### 2.7.3.2. 戻り値が配列のメソッドで、戻る配列のサイズが0の場合、メソッドを使用するクライアントの余計なnullチェックのロジックを回避するため、nullではなく長さゼロの配列を返却します

```java
//Bad
public String[] toArray(String s) {
    if (s == null || s.isEmpty()) {
        return null;
    }
    return new String[] { s };
}

public List<String> toList(String s) {
    if (s == null || s.isEmpty()) {
        return null;
    }
    return List.of(s);
}
```

```java
//Good
public String[] toArray(String s) {
    if (s == null || s.isEmpty()) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    return new String[] { s };
}

public List<String> toList(String s) {
    if (s == null || s.isEmpty()) {
        return Collections.emptyList();
    }
    return List.of(s);
}
```

#### 2.7.3.3. メソッドは1つの役割にします

メソッドは`単一責任の原則`に基づいて設計します。

`単一責任の原則`は、[付録](./java-coding-guide-recommendations.md)を確認してください。

メソッドにおける役割は1つのみ実装してください。

たとえば`getUserInfo`というメソッドが存在した場合、このメソッドはユーザーの情報を取得する機能のみを実装すべきです。

データを取得するまでに、DBにアクセスしたり、ネットワーク経由で別のサーバーに問い合わせを行うことを隠蔽するような実装を行います。

このメソッドに余計な処理（たとえば関係のないテーブルに更新処理を行うなど）を付け加えてしまうと、余計な責任を伴うことになります。

`getUserInfo`という名前から推測される挙動と異なる挙動を行うとバグの原因になるだけでなく、再利用ができないワンオフなメソッドになってしまいます。

```java
```

```java
//Good 
public UserInfo getUserInfo(final String userId) {
    return restTemplate.get...
}

public void setUserInfo(final UserInfo userInfo) {
    return restTemplate.post...
}

```

### 2.7.4. クラスメソッド

#### 2.7.4.1. クラスメソッドを利用するときは、クラス名を使って呼び出します

```java
//Bad
Integer a = ...
int comp = a.compare(x, y);
```

```java
//Good
int comp = Integer.compare(x, y);
```

### 2.7.5. 変数全般

#### 2.7.5.1. つのステートメントには1つの変数宣言します

```java
//Bad
private String code, name, shortName;
```

```java
//Good
/** 科目コード */
private String code;
/** 科目名 */
private String name;
/** 科目略名 */
private String shortName;
```

#### 2.7.5.2. リテラルの使用を禁止します

リテラルとは、コード中に、表現が定数として直接現れており、記号やリストで表現することができないものを指します（数値、文字列両方含む：通称マジックナンバー）。コードの可読性・保守性の低下を防ぐために、リテラル定数（`static final` フィールド）を使用してください。  
例外として`-1`,`0`,`1`等のカウント値としてループ処理等で使用するような場合は可能とします。

```java
//Bad
public double mileToMetre(double mi) {
    return mi * 1609.344;
}
```

```java
//Good
private static final double ONE_MILE_METRE = 1609.344;

public double mileToMetre(double mi) {
    return mi * ONE_MILE_METRE;
}
```

#### 2.7.5.3. リテラル定数の名前はその値の意味を正しく表現したものにします

```java
//Bad
private static final int ZERO = 0;
```

#### 2.7.5.4. 配列宣言は「`型名[]`」にします

```java
//Bad
private int sampleArray[] = new int[10];
```

```java
//Good
private int[] sampleArray = new int[10];
```

#### 2.7.5.5. できるだけローカル変数を利用します

ローカル変数で事足りるものをインスタンス変数として利用するなど、必要のないインスタンス変数を定義すると、パフォーマンスや可読性の低下やの大きな要因になります。
また、マルチスレッドを意識した際に不整合を起こす可能性があるため、インスタンス変数は必要性を充分に考慮してから使用してください。

### 2.7.6. 定数

#### 2.7.6.1. `public`で宣言するクラス変数とインスタンス変数は、定数のみとし、`static final`で定義します

`final` ではない `static` な定数の作成を禁止します。

```java
//Good
public static final String PROTOCOL_HTTP = "http";
```

#### 2.7.6.2. 定数（`static`フィールド）に、`static`ではないメソッドからの書き込みを強く推奨しません

staticフィールド内に対して更新が行われると、冪等性を失う可能性があります。

キャッシュ等で利用することがあると思いますが、必ずマルチスレッド時の挙動を確認し、実装を行なってください。

#### 2.7.6.3. 定数は、プリミティブ型もしくは、不変（Immutable）オブジェクトで参照します

#### 2.7.6.4. 不変`List`の生成には`List.of()`を利用します

```java
//Bad
public static final List<Integer> VALUES = Arrays.asList(1, 2, 3, 4, 5);
```

```java
//Good
public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
```

#### 2.7.6.5. 不変`Set`の生成には`Set.of()`を利用します

※Setは重複要素のないコレクションです。

```java
//Bad
public static final List<Integer> VALUES = Arrays.asList(1, 2, 3, 4, 5);
```

```java
//Good
public static final Set<Integer> VALUES = Set.of(1, 2, 3, 4, 5);
```

#### 2.7.6.6. 不変`Map`の生成には`Map.of()`を利用します

```java
//Bad
public static final Map<Integer, String> VALUES_MAP = new HashMap<>() {
    {
        put(1, "A");
        put(2, "B");
        put(3, "C");
    }
};
```

```java
//Good
public static final Map<Integer, String> VALUES_MAP = Map.of(1, "A", 2, "B", 3, "C");
```

#### 2.7.6.7. 不変な配列インスタンスは長さ0の配列以外は生成不可能なため、外部から参照される（`public`）定数では利用せず、`List`等への置き換えをしてください

配列で宣言した場合、配列は参照の値渡しをしているため、finalで宣言していたとしていても書き換えが可能です。

そのため、定数を配列の形で持ちたい場合は`List.of`を利用してください。

`List.of`の特徴として次のものが挙げられます。

- nullは許容しない
- 変更不可能である（追加・削除・置換ができない）
- リスト内の順序は、引数の順序、または指定された配列内の要素の順序と同じ
- value-vased

```java
//Bad finalで定数を宣言しているにも関わらずその正当性を担保することができません
public static final int[] VALUES = { 1, 2, 3, 4, 5 };
.
.
.
VALUES[0] = 2; //書き換え可能
```

```java
//Good 値の書き換えが不可能です
public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
.
.
.
VALUES.add(3); // java.lang.UnsupportedOperationException発生
VALUES.set(0, 3); // java.lang.UnsupportedOperationException発生
```

### 2.7.7. インスタンス変数

#### 2.7.7.1. インスタンス変数は`private`にします

```java
//Bad
public class Employee {
    public long id;

    //・・・
    //getter/setter
}
```

```java
//Good
public class Employee {
    private long id;

    //・・・
    //getter/setter
}
```

### 2.7.8. クラス変数

#### 2.7.8.1. `public static final`宣言した配列を利用を禁止します

※「定数」を参照

#### 2.7.8.2. クラス変数にはクラス名を使用してアクセスしてください

```java
//Bad
BigDecimal a = ...
BigDecimal b = a.ZERO;
```

```java
//Good
BigDecimal b = BigDecimal.ZERO;
```

### 2.7.9. ローカル変数

#### 2.7.9.1. ローカル変数は利用する直前で宣言します

```java
//Bad 実際に利用する場所よりあまりにも前に宣言されている
List<String> result = new ArrayList<>();
//Bad 必要ではないスコープに飛び出して宣言されている
String line;
.
.
.
for (int i = 0; i < lines.length; i++) {
    line = lines[i];
    //lineの処理
    ...
    result.add(line);//実際にはlineの処理を行なった後のもの
}

return result;

```

```java
//Good
.
.
.
List<String> result = new ArrayList<>();
for (int i = 0; i < lines.length; i++) {
    String line = lines[i];
    //lineの処理
    ...
    result.add(line);//実際にはlineの処理を行なった後のもの
}

return result;

```

#### 2.7.9.2. ローカル変数は安易に再利用してはいけません

一度宣言したローカル変数を、複数の目的で安易に使いまわすことを禁止します。ローカル変数は、役割ごとに新しいものを宣言して初期化することにより、コードの可読性・保守性の向上、及びコンパイラの最適化、ガベージコレクションの最適化の促進をはかります。

`final`参照。

### 2.7.10. 引数

#### 2.7.10.1. メソッド引数への代入を禁止します

原則として引数は`final`で宣言する。

```java
public void add(final int value) {
    //・・・
}
```

### 2.7.11. 継承

#### 2.7.11.1. スーパークラスのインスタンス変数をサブクラスでオーバーライドを禁止します

スーパークラスと同じ名前のフィールドをサブクラスで宣言は禁止します。 同じ名前のフィールドを宣言した場合、スーパークラスのフィールドはサブクラスで宣言されたフィールドによって隠ぺいされてしまいます。他の人の混乱を招くことを防ぐため重複する名前は付けては行けません。

```java
//Bad
public class Abs {
    protected String name;
}

public class Sub extends Abs {
    protected String name;//Abs#nameは隠ぺいされる
}
```

#### 2.7.11.2. スーパークラスのメソッドをオーバーライドするときは@Overrideアノテーションを指定します

```java
//Bad
public class Abs {
    protected void process() {

    }
}

public class Sub extends Abs {
    //@Overrideアノテーションの指定がない
    protected void process() {

    }
}
```

```java
//Good
public class Abs {
    protected void process() {

    }
}

public class Sub extends Abs {
    @Override
    protected void process() {

    }
}
```

#### 2.7.11.3. スーパークラスで`private`宣言されているメソッドと同じ名前のメソッドをサブクラスで定義することを禁止します

スーパークラスにある`private`メソッドと同じ名前のメソッドをサブクラスで定義してはいけません。`private`メソッドはオーバーライドされずまったく別のメソッドとして扱われるため、他の人の混乱を招き、バグにつながる恐れがあります。

### 2.7.12. インナークラス

#### 2.7.12.1. 原則としてインナークラスは利用はしないでください

ひとつのjavaファイルに複数のクラスを記載するのは禁止します。また無名クラスを利用するのも原則として禁止です。  
Enumの定数固有メソッド実装（constant-specific method implementation）、Java8のラムダ式は内部的にインナークラスとされますがこれらは許可します。

### 2.7.13. メンバー順序

メンバー変数は次の順で記述します。

1. static フィールド
2. static イニシャライザー
3. static メソッド
4. フィールド
5. イニシャライザー
6. コンストラクター
7. メソッド

また、同一カテゴリー内では次の可視性の順で記述します。

1. public
2. protected
3. パッケージ private
4. private

### 2.7.14. インスタンス

#### 2.7.14.1. オブジェクト同士は`equals()`メソッドで比較します

オブジェクト同士の比較に`==`を使用することは禁止します。

Enumの場合は`==`演算子を利用して比較して下さい。

`equals()`メソッドで比較する際、左辺のオブジェクトが`null`にならないように制御して下さい。

```java
//Bad
String s1 = "text";
String s2 = "text";
if (s1 == s2) {
    //・・・
}
```

```java
//Good
String s1 = "text";
String s2 = "text";
if (s1.equals(s2)) {
    //・・・
}
```

#### 2.7.14.2. Class名を利用した比較を禁止します

```java
//Bad
if ("my.Foo".equals(o.getClass().getName())) {
    Foo f = (Foo)o;
    ...
}
```

```java
//Good
if (o instanceof Foo f) {
    ...
}
```

#### 2.7.14.3. インスタンスの型キャスト（Classキャスト）が必要な場合はパターンマッチングを使用して下さい

```java
//Bad
if (o instanceof String) {
    String s = (String)o;
    // ...
}

var str = (o instanceof BigDecimal) ? ((BigDecimal)o).toPlainString() : String.valueOf(o);

var empty = o == null ||
    (o instanceof String && ((String)o).isEmpty()) ||
    (o instanceof Collection && ((Collection)o).isEmpty());
```

```java
//Good
if (o instanceof String s) {
    // ...
}

var str = (o instanceof BigDecimal b) ? b.toPlainString() : String.valueOf(o);

var empty = o == null ||
    (o instanceof String s && s.isEmpty()) ||
    (o instanceof Collection c && c.isEmpty());
```

### 2.7.15. 制御構造

#### 2.7.15.1. 制御文（`if`, `else`, `while`, `for`, `do while`）の `{ }` は省略を禁止します

```java
//Bad
if (s == null)
    return;
```

```java
//Good
if (s == null) {
    return;
}
```

#### 2.7.15.2. ステートメントがない`{}`ブロックの利用を禁止します

```java
//Bad {}内の記述が無い
if (s == null) {
    // do not something
} else {
    ...
}
```

```java
//Good
if (s != null) {
    ...
}
```

#### 2.7.15.3. `if`/`while`の条件式で`=`の利用を禁止します

```java
//Bad
boolean a =//
if (a = false) {//コーディングミス
    //・・・
}

boolean a =//
boolean b =//
if (a = b) {//おそらくコーディングミス
    //・・・
}
```

```java
//Good
boolean a =//
if (!a) {
    //・・・
}
```

#### 2.7.15.4. `for`と`while` の使い分けを意識してください

for文は初期値が構文内に内包されるのに対し、while文は内包しません。

そのため、for文は繰り返しの回数を指定するループ処理に適しています。

while文は何かの条件に対してのループ処理に適しています。

使い分けを行い、適切なループ処理で実装してください。

#### 2.7.15.5. for文を利用した繰り返し処理中でループ変数の値の変更を禁止します

```java
//Bad
String[] array = { /*・・・*/ };
for (int i = 0; i < array.length; i++) {
    //・・・
    i += 2;//Bad
}

for (String s : array) {
    //・・・
    s = "string";//Bad
}
```

```java
//Good
String[] array = { /*・・・*/ };
for (final int i = 0; i < array.length; i++) {
    //・・・
    i += 2;// Error
}

for (final String s : array) {
    //・・・
    s = "string";//Error
}
```

#### 2.7.15.6. ノーマルfor文のカウンタは特別な事情がない限り、0から始めて下さい

ノーマルfor文のカウンタの初期値に`10`など特殊な値から始める場合、**必ず**定数で初期値の意味を宣言してください。

※[ノーマルfor文は導入「1.4.表記ルール」参照](./java-coding-guide-introduction.md)

#### 2.7.15.7. 配列やリストなどの全要素に対するループ処理は拡張for文を使用して下さい

※streamを用いても構いません。

```java
//Good
for (final int value : array) {
    //・・・
}

for (final String value : list) {
    //・・・
}
```

#### 2.7.15.8. 反復処理中に反復処理の条件となるList、配列の変更を禁止します

for文などを利用し、条件となるListの条件を変更した場合、変数の再代入が発生し、可読性が低下します。

そのため反復処理で要素に対して処理を行う場合は、結果用のListや配列を別途宣言してください。

また、拡張for文の処理中に条件となる変数に対して要素の追加、削除を行うと例外が発生します。

[`ConcurrentModificationException`](https://docs.oracle.com/javase/jp/8/docs/api/java/util/ConcurrentModificationException.html)

#### 2.7.15.9. 配列をコピーするときは`Arrays.copyOf()`メソッドを利用して下さい

```java
//Bad
int[] newArray = new int[array.length];
System.arraycopy(array, 0, newArray, 0, array.length);
```

```java
//Good
int[] newArray = Arrays.copyOf(array, array.length);
```

#### 2.7.15.10. 繰り返し処理中のオブジェクトの生成は最小限にして下さい

繰り返し処理中にインスタンスの生成を行うとパフォーマンスが著しく下がります。

必要最低限のインスタンスの生成を行うようにしてください。

繰り返し処理の場合、インスタンスの使い回しをしても問題ありません。

#### 2.7.15.11. if文とelse文の繰り返しやswitch文の利用はなるべく避け、オブジェクト指向の手法を利用して下さい

```java
//Bad
switch (kind) {
case 1 ->
    d = encode1(s);
case 2 ->
    d = encode2(s);
}

//---

switch (kind) {
case 1 ->
    s = decode1(d);
case 2 ->
    s = decode2(d);
}
```

```java
//Good
CodingKind codingKind = toCodingKind(kind);
d = codingKind.encode(s);

//---

CodingKind codingKind = toCodingKind(kind);
s = codingKind.decode(d);
```

#### 2.7.15.12. 繰り返し処理の内部で `try` ブロックを禁止します

特に理由がない場合は繰り返し処理の外に`try`ブロックを記載して下さい。

ただし、繰り返し処理内部で例外をキャッチし処理を行いたい場合は繰り返し処理の内部で`try`ブロックを利用してもよいです。

```java
//Good
for (String s : array) {
    BigDecimal num;
    try {
        num = new BigDecimal(s);
    } catch (NumberFormatException e) {
        num = BigDecimal.ZERO;
    }
    //・・・
}
```

### 2.7.16. 文字列操作

#### 2.7.16.1. 文字列同士が同じ値かを比較するときは、`equals()`メソッドを利用します  

```java
//Bad
String s1 = "text";
String s2 = "text";
if (s1 == s2) {
    //・・・
}
```

```java
//Good
String s1 = "text";
String s2 = "text";
if (s1.equals(s2)) {
    //・・・
}
```

#### 2.7.16.2. 文字列リテラルは`new` しない  

```java
//Bad
String s = new String();
```

```java
//Good
String s = "";
```

#### 2.7.16.3. 更新される文字列には`StringBuilder` クラスを利用して下さい

スレッドセーフ性が保証されていない箇所では`StringBuffer`クラスを利用して下さい。

<!-- TODO: [※パフォーマンスについても記載しているので参考にしてください](#文字列連結) -->

```java
//Bad
String string = "";
for (String s : array) {
    string += s;
}
System.out.println(string);
```

```java
//Good
StringBuilder builder = new StringBuilder();
for (String s : array) {
    builder.append(s);
}
System.out.println(builder.toString());
```

#### 2.7.16.4. １ステートメントのみで行われる文字列の連結には`+`演算子を利用する

// TODO:パフォーマンスの話をする。

```java
//Bad
String s = new StringBuilder(s1).append(s2).toString();

return new StringBuilder(s1).append(s2).append(s3).append(s4).append(s5).toString();
```

```java
//Good
String s = s1 + s2;

return s1 + s2 + s3 + s4 + s5;
```

#### 2.7.16.5. 更新されない文字列には`String`クラスを利用します

StringBuilderは、どのような文字列が変数に入るか分からない処理に適しています。

更新されない文字列の場合、Stringを用いた方がコンパイラの最適化が効くためStringを利用してください。

#### 2.7.16.6. 文字列リテラルと定数を比較するときは、文字列リテラルの`equals()`メソッドを利用します

```java
//Bad
private static final String PROTOCOL_HTTP = "http";

if (url.getProtocol().equals(PROTOCOL_HTTP)) {

}
```

```java
//Good
private static final String PROTOCOL_HTTP = "http";

if (PROTOCOL_HTTP.equals(url.getProtocol())) {

}
```

#### 2.7.16.7. プリミティブ型と`String` オブジェクトの変換には、変換用のメソッドを利用します

```java
int i = 1000;
String s = String.valueOf(i);// "1000"
s = NumberFormat.getNumberInstance().format(i);// 3桁区切り "1,000"

boolean b = true;
s = String.valueOf(b);// true/false
s = BooleanUtils.toStringOnOff(b);// on/off
```

#### 2.7.16.8. 文字列の中に、ある文字が含まれているか調べるには、`contains()`メソッドを利用します

```java
if ([1, 2, 3].contains(target)) {
    ...
}
```

#### 2.7.16.9. システム依存記号（`\n`、`\r`など）は使用を禁止します

```java
String text = Arrays.stream(array)
    .collect(Collectors.joining("\n"));
```

### 2.7.17. 数値

#### 2.7.17.1. 誤差のない計算をするときは、`BigDecimal` クラスを使用します

浮動小数点演算は科学技術計算に利用するもので、誤差が発生する。これに対して、クラス「`BigDecimal`」は、文字列で数値の計算を行うので、金額などの正確な計算に適している。`BigDecimal` ではインスタンス生成時に指定された桁数での精度が保証される。

#### 2.7.17.2. 数値の比較は精度に気をつけてください

```java
//Bad
BigDecimal a = new BigDecimal("1");
BigDecimal b = new BigDecimal("1.0");

if (a.equals(b)) {
    System.out.println("精度が違うためこの分岐には入らない");
}
```

```java
//Good
BigDecimal a = new BigDecimal("1");
BigDecimal b = new BigDecimal("1.0");
if (a.compareTo(b) == 0) {
    System.out.println("一致");
}
```

#### 2.7.17.3. 低精度なプリミティブ型にキャストを強く推奨しません

低精度なプリミティブ型にキャストする場合、キャストした型の精度に値が変更されます。

#### 2.7.17.4. `BigDecimal`を`String`変換する際は`toString()`ではなく`toPlainString()`を利用してください

`toString()`を利用した場合、指数表記になることがあります。

### 2.7.18. 日付

#### 2.7.18.1. 日付の文字列のフォーマットには、`SimpleDateFormat`または`DateTimeFormatter`を利用してください

```java
Date date = new Date();
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
String s = dateFormat.format(date);
```

### 2.7.19. 三項演算子

#### 2.7.19.1. 入れ子の三項演算子の利用は禁止します

可読性が悪くなるので三項演算子を入れ子で行うのは禁止。

### 2.7.20. switch式

#### 2.7.20.1. ひとつの値を変数に代入するための if-else 文は代わりに switch 式の使用を推奨します

switch 式の値を使用することで変数を不変（実質的 final）にでき、代入箇所が分散することによる可読性の低下を防げます。

```java
//Bad
int value;
if (op.equals("add")) {
    value = a + b;
} else {
    value = a - b;
}
```

```java
//Good
var value = switch (op) {
    case "add" -> a + b;
    default -> a - b;
};
```

#### 2.7.20.2. case句はなるべくひとつの式での記述を推奨します

複雑な式や複雑なステートメントを記述しなければならない場合は、メソッドに分割することを検討してください。

#### 2.7.20.3. switch 式は、コーディングミスによるフォールスルーを避けるため、常にアロー構文を使用します

[https://docs.oracle.com/javase/jp/16/language/switch-expressions.html](https://docs.oracle.com/javase/jp/16/language/switch-expressions.html)からの引用：

> ノート:`case L ->`ラベルの使用をお薦めします。`case L:`ラベルの使用時は、`break`文または`yield`文の挿入を忘れがちです。これを忘れると、コード内で思いがけないフォール・スルーが発生する場合があります。
> `case L ->`ラベルで、複数の文または式でないコード、あるいは`throw`文を指定するには、それらをブロック内に囲みます。`case`ラベルが生成する値を`yield`文で指定します。

```java
//Bad
var date = LocalDate.now();
var off = switch (date.getDayOfWeek()) {
    case MONDAY:
        if (myCalendar.isOff(date) || localCalendar.isHoliday(date)) {
            yield true;
        }
        yield localCalendar.isHoliday(date.minusDays(1));
    case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY:
        yield myCalendar.isOff(date) || localCalendar.isHoliday(date);
    case SUNDAY, SATURDAY:
        yield true;
};
```

```java
//Good
var date = LocalDate.now();
var off = switch (date.getDayOfWeek()) {
    case MONDAY -> {
        if (myCalendar.isOff(date) || localCalendar.isHoliday(date)) {
            yield true;
        }
        yield localCalendar.isHoliday(date.minusDays(1));
    }
    case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY ->
        myCalendar.isOff(date) || localCalendar.isHoliday(date);
    case SUNDAY, SATURDAY -> true;
};
```

#### 2.7.20.4. アロー構文の、中カッコ、`yield`を省略できる場合は必ず省略してください 

```java
//Bad
var day = DayOfWeek.SUNDAY;
var shortDay = switch (day) {
    case MONDAY -> {
        yield "M";
    }
    case WEDNESDAY -> {
        yield "W";
    }
    case FRIDAY -> {
        yield "F";
    }
    case TUESDAY, THURSDAY -> {
        yield "T";
    }
    case SUNDAY, SATURDAY -> {
        yield "S";
    }
};
```

```java
//Good
var day = DayOfWeek.SUNDAY;
var shortDay = switch (day) {
    case MONDAY -> "M";
    case WEDNESDAY -> "W";
    case FRIDAY -> "F";
    case TUESDAY, THURSDAY -> "T";
    case SUNDAY, SATURDAY -> "S";
};
```

#### 2.7.20.5. Enum値のswitch式でcase句がすべてのEnum値をカバーする場合はdefault句はデッドコードとなるため記述は不要です

```java
var day = DayOfWeek.SUNDAY;
var off = switch (day) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
    case SUNDAY, SATURDAY -> true;
};

var day = DayOfWeek.SUNDAY;
var off = switch (day) {
    case SUNDAY, SATURDAY -> true;
    default -> false;
};
```

```java
var day = DayOfWeek.SUNDAY;
var off = switch (day) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
    case SUNDAY, SATURDAY -> true;
    default -> false;
};
```

### 2.7.21. switch 文

#### 2.7.21.1. 代わりにswitch式が使用できる箇所はswitch式を使用します

case句で`return`を記述する場合はswitch文を使用してよい。

#### 2.7.21.2. case 句はなるべく 1 行のステートメントでの記述を推奨します

複雑なステートメントを記述しなければならない場合は、メソッドに分割することを検討してください。

#### 2.7.21.3. switch 文は、コーディングミスによるフォールスルーを避けるため、なるべくアロー構文を使用することを推奨します

[https://docs.oracle.com/javase/jp/16/language/switch-expressions.html](https://docs.oracle.com/javase/jp/16/language/switch-expressions.html)からの引用：

> ノート:`case L ->`ラベルの使用をお薦めします。`case L:`ラベルの使用時は、`break`文または`yield`文の挿入を忘れがちです。これを忘れると、コード内で思いがけないフォール・スルーが発生する場合があります。
> `case L ->`ラベルで、複数の文または式でないコード、あるいは`throw`文を指定するには、それらをブロック内に囲みます。`case`ラベルが生成する値を`yield`文で指定します。

```java
//Bad
var date = LocalDate.now();
switch (date.getDayOfWeek()) {
    case MONDAY:
        if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date) &&
            !localCalendar.isHoliday(date.minusDays(1))) {
            work();
        }
        break;
    case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY:
        if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date)) {
            work();
        }
        break;
}
```

```java
//Good
var date = LocalDate.now();
switch (date.getDayOfWeek()) {
    case MONDAY -> {
        if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date) &&
            !localCalendar.isHoliday(date.minusDays(1))) {
            work();
        }
    }
    case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> {
        if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date)) {
            work();
        }
    }
}
```

#### 2.7.21.4. アロー構文を使用しない（コロンを使用する）場合、複数の値をマッチさせるときの case 句はカンマを使用して列挙してください

```java
//Good
var day = DayOfWeek.SUNDAY;
boolean off = false;
switch (day) {
    case SUNDAY, SATURDAY:
    off = true;
    break;
};
```

```java
//Bad
var day = DayOfWeek.SUNDAY;
boolean off = false;
switch (day) {
    case SUNDAY:
    case SATURDAY:
    off = true;
    break;
};
```

### 2.7.22. コレクション

#### 2.7.22.1. Java2 以降のコレクションクラスを利用します

`Vector` クラス、`Hashtable` クラス、`Enumeration` 等は、特にこれらを利用する理由がなければ、インターフェースを統一する目的で、これらの代わりに`List`(`ArrayList` クラス)、`Map`(`HashMap` クラス)、`Iterator` を使用すること。`List` などのインターフェースを利用することで JDK1.2 で整理されたわかりやすいメソッドを利用でき、また、インターフェースの特性から呼び出し元を変更せずに実装クラスを変更することができる。

#### 2.7.22.2. 特定の型のオブジェクトだけを受け入れるコレクションクラスを利用します

```java
//Good
List<Map<String, String>> list = new ArrayList<>();
```

#### 2.7.22.3. `List`のソートは`List.sort()`を利用する  

`List`クラスの要素をソートする際は Java8 で追加された`List.sort()`を利用すること。  
Java 7 以前で利用されていた`Collections.sort()`は利用を禁止します。

#### 2.7.22.4. `Collection.forEach()`は利用しない。拡張for文の利用を検討してください

Java8で追加されたメソッド。
拡張for文を利用したほうが多くの場合でデバッグに有利であり、可読性においても`forEach`の優位性は少ないため、`forEach`は原則利用しない。拡張for文を利用する。  
具体的には次のメソッドを利用しないこと。

- `Collection#forEach`
- `Set#forEach`
- `List#forEach`

※ `Map#forEach`はこの限りではない

```java
//Bad
List.of("A", "B").forEach(s -> {
    ...
});
```

```java
//Good
for (final String s : List.of("A", "B")) {
    ...
}
```

ただし、メソッド参照で処理できる場合は`forEach`を利用する。（デバッグのデメリットがほとんどなく、他と比較して処理効率がよいため）

```java
List.of("A", "B").forEach(this::process);
```

```java
for (String s : List.of("A", "B")) {
    this.process(s);
}
```

#### 2.7.22.5. `Arrays.asList()`は利用せず、`List.of()`を利用します

Java9 で追加されたメソッド。  
配列を`List`に置き換える場合や、単純な固定の`List`を生成する際には`List.of()`を利用する。

#### 2.7.22.6. `Arrays.asList()`と`List.of()`の違い

`List.of()`で生成した`List`は、完全に不変（Immutable）な`List`で、`Arrays.asList()`で生成した`List`は、サイズのみ不変で、`set`等による値の操作が可能な`List`です。  

また、`set`を行った場合、`Arrays.asList()`に与えられた配列インスタンスにも影響します。

### 2.7.23. ラムダ式・メソッド参照・コンストラクタ参照

#### 2.7.23.1. ラムダ式が利用できる箇所はラムダ式を利用してよいです

<!-- TODO: [※パフォーマンスについても記載しているので参考にしてください](#ラムダ式・メソッド参照・コンストラクタ参照-2) -->

#### 2.7.23.2. メソッド参照・コンストラクタ参照が利用できる場合はメソッド参照・コンストラクタ参照を利用します

```java
//Bad
(s1, s2) -> s1.compareToIgnoreCase(s2)
```

```java
//Good
String::compareToIgnoreCase
```

```java
//Bad
(b1, b2) -> b1.add(b2)
```

```java
//Good
BigDecimal::add
```

#### 2.7.23.3. ラムダ式記述の際、型宣言は省略記法で記述します

```java
//Bad
(String s1, String s2) -> s1 + "=" + s2
```

```java
//Good
(s1, s2) -> s1 + "=" + s2
```

#### 2.7.23.4. 原則ラムダ式内の行数は1行とします

複数行で利用したい場合は、`private`メソッドを作成しメソッド参照を利用します。

```java
//Bad
(i1, i2) -> {
    if (i1 > i2) {
        return i1;
    } else {
        return i2;
    }
}
```

```java
//Good
this::getMax

private int getMax(int i1, int i2) {
    if (i1 > i2) {
        return i1;
    } else {
        return i2;
    }
}
```

#### 2.7.23.5. 原則ラムダ式は 1 行記述に限定するので、中カッコ、`return`は必ず省略します

```java
//Bad
(s1, s2) -> {
    return s1 + "=" + s2;
}
```

```java
//Good
(s1, s2) -> s1 + "=" + s2
```

### 2.7.24. Stream API

#### 2.7.24.1. 並列ストリームは利用を原則禁止します

```java
//Bad
Stream<?> s = list.parallelStream();
Stream<?> s = list.stream().parallel();
```

#### 2.7.24.2. 中間処理の数は 3 つ（3 行）程度までを推奨します

中間処理の記述が多くなると可読性も悪くなり、デバッグも難しくなるため、3 行程度を目安にロジックを検討すること。

#### 2.7.24.3. コメントは、原則として処理中には記載してはいけません

難解になってしまった場合のみ処理中の記載を認めますが、コメントが必要になった時点でメソッドチェーンを使用することが不適切な場合もあるため注意してください。

可読性を重視し、コーディングするよう心がけてください。

```java
//Bad
fooList.stream()
    .sorted(Comparator.comparing(Foo::getStr)) //クラスFooのフィールドStrの値で昇順にソート
    .map (Foo::getStr) //フィールドStrの要素を取得
    .forEach(this::proc); //処理

fooList.stream()
    //クラスFooのフィールドStrの値で昇順にソート
    .sorted(Comparator.comparing(Foo::getStr))
    //フィールドStrの要素を取得
    .map (Foo::getStr)
    //処理
    .forEach(this::proc);
```

```java
//Good
// クラスFooのフィールドStrの値で昇順にソートし、フィールドStrの要素を取得して処理する。
fooList.stream()
    .sorted(Comparator.comparing(Foo::getStr))
    .map(Foo::getStr)
    .forEach(this::proc);
```

#### 2.7.24.4. Stream は極力変数代入しないようにしてください

Stream は中間処理、末端処理を行うと使用済みとなり、以降同じインスタンスは利用しないでください。  

変数代入はほとんどの場合意味をなさず、むしろミスの元となるため極力変数代入はしないようにしてください。

```java
//Bad
Stream<String> stream = Stream.of("A", "B", "C");
Stream<String> stream1 = stream.map(String::toLowerCase);
List<String> list1 = stream1.toList();

Stream<String> stream2 = stream.map(s -> s + s);//コーディングミス streamは使用済のためエラーになる
List<String> list2 = stream2.toList();
```

```java
//Good
List<String> list1 = Stream.of("A", "B", "C")
        .map(String::toLowerCase)
        .toList();

List<String> list2 = Stream.of("A", "B", "C")
        .map(s -> s + s)
        .toList();
```

### 2.7.25. Optional

#### 2.7.25.1. Optional は同メソッド内で値を取り出す場合は極力変数代入しないこと

Optional とその値の変数は同じものを示す名前となり、同じ意味の変数名が複数現れることで可読性が下がるため、Optional の変数代入は行わないこととする。

```java
//Bad
Optional<Employee> employeeOpt = findEmployee(employeeId);
Employee employee = employeeOpt.orElseThrow(IllegalArgumentException::new);
```

```java
//Good
Employee employee = findEmployee(employeeId)
        .orElseThrow(IllegalArgumentException::new);
```

直接、値を取り出すことなくOptionalでのみ扱う場合はOptionalを変数代入してもよいです。

```java
//Good
Optional<Employee> employee = findEmployee(employeeId);

Dept dept = employee.map(Employee::getDivision)
        .map(Division::getDept)
        .orElse(null);

Role role = employee.map(Employee::getRole)
        .orElse(null);

//-----

Optional<Employee> employee = findEmployee(employeeId);
//・・・処理
return employee;
```

### 2.7.26. var（Local-Variable Type Inference）

次のリンクも参考にしてください。
[Style Guidelines for Local Variable Type Inference in Java](https://openjdk.java.net/projects/amber/LVTIstyle.html)

#### 2.7.26.1. 明確な方針で、利用する・利用しないを統一してください

方針無く、`var`を混在させるとソースコードの見通しと保守性が悪くなります。  
各プロジェクトで、たとえば次のような方針で統一してください。

1. `var`を利用しない
2. 原則`var`を利用する
3. 右辺で、明確に型が分かる場合は`var`を利用する

以下で`2`、`3`について例を示します。

- 原則`var`を利用する

利用できる箇所はすべて`var`を利用します。

```java
//Bad
var a = "";
int b = 123;
List<String> c = new ArrayList<>();

void methodA() {
    var a = "";
}
void methodB() {
    String a = "";
}
```

```java
//Good
var a = "";
var b = 123;
var c = new ArrayList<String>();

void methodA() {
    var a = "";
}
void methodB() {
    var a = "";
}
```

#### 2.7.26.2. 右辺で、明確に型が分かる場合は`var`を利用する場合

右辺をみて型が分かる場合は、すべて`var`を利用します。
それ以外は`var`を利用してはいけません。

```java
var s = ""; // リテラルによって型が明確に判断できます
var list1 = new ArrayList<String>(); // newによって型が明確に判断できます
var list2 = (List<String>) map.get("p"); // キャストによって型が明確に判断できます
var list3 = List.of("A", "B", "C"); // ファクトリーによって型が明確に判断できます
```

 プロジェクトで観点を決めるべき例：

```java
//Good
var b1 = s.isEmpty(); // `is`で始まるメソッドは通例としてbooleanを返します
var b2 = Objects.equals(s1, s2); // `equals`メソッドは通例としてbooleanを返します
var i1 = Objects.hash(s); // `hash`、`hashCode`メソッドは通例としてintを返します
var i2 = Objects.compare(s1, s2); // `compare`、`compareTo`メソッドは通例としてintを返します
```

```java
//Bad
var a = e.getData(); // `e`の型と、メソッド定義がわからなければ型が判断できません
```

### 2.7.27. レコード・クラス

#### 2.7.27.1. 明確な方針で、利用する・利用しないを統一してください

方針無く、`record`とクラスと JavaBeans 形式のクラスや`Lombok`の`@Data`の使用を混在させるとソースコードの見通しと保守性が悪くなります。  
各プロジェクトで、`record`を利用しないか、`record`の使用してもよい箇所について方針を決めた上で使用するようにしてください。
また、`record`は JavaBeans とは互換性がないため使用している各種ライブラリの対応状況にも注意する必要があります。

方針例： クラス内で処理する一時的なデータを表現するためだけに`record`を使用してもよい。

```java
// parentId と id をキーとして、重複を排除した uniqueItems を作成します。
record Key(int parentId, int id) {
}
var map = new HashMap<Key, Item>();
for (Item item : items) {
var key = new Key(item.getParenId(), item.getId());
map.putIfAbsent(key, item);
}
var uniqueItems = map.values();
```

#### 2.7.27.2. 次の記述スタイルを標準としてください

ただし、ソルクシーズスタンダード以外のフォーマッタを導入している場合はフォーマッタに合わせてください。

```java
/**
* 矩形を表すクラス
*
* @param x      矩形の左上隅の x 座標
* @param y      矩形の左上隅の y 座標
* @param width  矩形の幅
* @param height 矩形の高さ
*/
public record Rect(
    /* 矩形の左上隅の x 座標 */
    double x,
    /* 矩形の左上隅の y 座標 */
    double y,
    /* 矩形の幅 */
    double width,
    /* 矩形の高さ */
    double height) {
}
```

次にポイントを説明します。

- `{`の後、`}`の前に改行する
- レコードコンポーネント（パラメータ）のカンマの後に改行することを推奨する  
  レコードコンポーネントが少なく、レコードコンポーネント名からでも意味が理解でき、改行がなくても可読性が低下しない場合は、改行を必要としません

改行を推奨する理由は以下です。

- アノテーションを付与したときでも比較的読みやすい（アノテーション引数との混在による可読性の低下の回避）
- レコードコンポーネントが多い場合も比較的読みやすい
- レコードコンポーネントが多い場合、レコードコンポーネントへ直接コメントをつけることを検討する  
  レコードコンポーネントの JavaDoc としては`@param`形式でレコード名の上部に記述しますが、このソースコードをテキストとしてみた場合、レコードコンポーネントの定義と`@param`の説明とで距離が空いてしまう場合があり、型と説明を読むのに時間がかかってしまう可能性があります。  
  また、使用する IDE によっては、アクセサから宣言へのジャンプを使用すると、レコードコンポーネント（パラメータ）の定義へジャンプするものがあります。レコードコンポーネントにコメントがあればすぐに説明を読むことができますが、JavaDoc しか記述しない場合は、ファイル上部へ移動して対応するレコードコンポーネントの説明を探さなければなりません

```java
public record Rect(
    /* 矩形の左上隅の x 座標 */
    double x,
    /* 矩形の左上隅の y 座標 */
    double y,
    /* 矩形の幅 */
    double width,
    /* 矩形の高さ */
    double height) {
}
```

#### 2.7.27.3. レコードのアクセサの上書きを禁止します

```java
//Bad
public record Rect(
    double x,
    double y,
    double width,
    double height) {

    public double x() {
        return x;
    }
}
```

### 2.7.28. テキストブロック

次のリンクも参考にしてください。  
[Programmer's Guide To Text Blocks > Style Guidelines For Text Blocks](https://docs.oracle.com/en/java/javase/17/text-blocks/index.html#style-guidelines-for-text-blocks)

#### 2.7.28.1. 複数行の文字列を定義する際、文字列連結よりもテキストブロックを使用します

```java
//Bad
String message =
        "複数行の文字列はテキストブロックを使用しましょう。\n" +
        "文字列連結と違い、プラス記号や改行コードのエスケープシーケンスのような無駄を排除でき、\n" +
        "より読みやすいソースコードで書くことができます。\n";
```

```java
//Good
String message = """
        複数行の文字列はテキストブロックを使用しましょう。
        文字列連結と違い、プラス記号や改行コードのエスケープシーケンスのような無駄を排除でき、
        より読みやすいソースコードで書くことができます。
        """;
```

#### 2.7.28.2. 単一行の文字列を定義する際、テキストブロックは使用せず文字列リテラルを使用します

ただし、二重引用符(`"`)のエスケープを避ける目的ではテキストブロックを使用してもよいです。

```java
//Bad
String singleLine = """
        単一行の文字列です。""";
```

```java
//Good
String singleLine = "単一行の文字列です。";

String message = """
        テキストブロックでは単一の二重引用符「"」にエスケープを使用する必要がありません。""";
```

#### 2.7.28.3. テキストブロック内では基本的に改行コードのエスケープシーケンス(`\n`)を使用しないが、読みやすさ向上の目的で改行コードのエスケープシーケンス(`\n`)を使用してもよいです

```java
//Bad
String multiLine = """
        複数行の、\n文字列です。
        """;
```

```java
//Good
String multiLine = """
        複数行の、
        文字列です。
        """;

String csv = """
        名前,説明,MIMEタイプ
        CSV,"Comma-Separated Valuesの略\nCharacter-Separated Valuesの意味で使用されることもある","text/csv"
        TSV,"Tab-Separated Valuesの略","text/tab-separated-values"
        """;
```

#### 2.7.28.4. テキストブロックで定義した文字列を処理する場合は、テキストブロックをローカル変数やフィールドへ代入してから使用することを推奨します

複雑な処理に直接テキストブロックを使用すると可読性を下げる可能性がありますので注意してください。

```java
//Bad
processValues(fetch("""
        SELECT
            ID,
            NAME
        FROM
            TABLE_X
        """, Entity1.class), fetch("""
        SELECT
            ID,
            NAME
        FROM
            TABLE_Y
        """, Entity2.class));
```

```java
//Good
String selectX = """
        SELECT
            ID,
            NAME
        FROM
            TABLE_X
        """;
String selectY = """
        SELECT
            ID,
            NAME
        FROM
            TABLE_Y
        """;
processValues(fetch(selectX, Entity1.class), fetch(selectY, Entity2.class));
```

#### 2.7.28.5. つ以上続く二重引用符(`"`)をエスケープする際は、最初の二重引用符にエスケープシーケンスを使用します

```java
//Bad
String javaCode = """
        String message = \"\"\"
                テキストブロックです。
                \"\"\";
        System.out.println(message);
        """;

String javaCode = """
        String message = ""\"
                テキストブロックです。
                ""\";
        System.out.println(message);
        """;
```

```java
//Good
String javaCode = """
        String message = \"""
                テキストブロックです。
                \""";
        System.out.println(message);
        """;
```

#### 2.7.28.6. テキストブロックの開始引用符(`"""`)は前の行の右端に記述します

```java
//Good
String message = """
        テキストブロックです。
        """;
```

```java
//Bad
String message =
        """
        テキストブロックです。
        """;
```

#### 2.7.28.7. テキストブロックのインデントは開始引用符(`"""`)に合わせる必要はありません

```java
//Good
String message = """
        テキストブロックです。
        """;
```

```java
//Bad
String message = """
                テキストブロックです。
                """;
```

一見すると、読みやすく見えるかもしれませんが、変数名の変更によって簡単に崩れてしまい、修正するために多くの行の変更を強制することになるため、メンテナンス性が低下します。

#### 2.7.28.8. テキストブロックで定義する文字列のインデントは基本的に周辺のJava コードに合わせてインデントします

ただし、横に長い文字列などの可読性向上の目的で左端に揃えるのはよいです。

```java
//Bad
public class Foo {
    public void process() {
        String message = """
    テキストブロックです。
    """;
    }
}
```

```java
//Good
public class Foo {
    public void process() {
        String message = """
                テキストブロックです。
                """;
    }
}
```

```java
//Bad
public class Foo {
    public void process() {
        if (foo) {
            String message = """
                    それはもう長い長いテキストブロックのためインデントするとエディタ上でテキストを見るためには横スクロールが必要になるかもしれません。
                    """;
        }
    }
}
```

```java
//Good
public class Foo {
    public void process() {
        if (foo) {
            String message = """
それはもう長い長いテキストブロックのためインデントするとエディタ上でテキストを見るためには横スクロールが必要になるかもしれません。
""";
        }
    }
}
```

#### 2.7.28.9. テキストブロックのインデントにスペース文字とタブ文字を混在を禁止します

フォーマッタにしたがって、インデントは統一してください。

#### 2.7.28.10. 文字列の最後に改行コードを入れずに、意図的にインデントした文字列を定義するとき終了引用符(`"""`)の前の行の右端に`\`を使用します

```java
//Bad
String text = """
        ABC
        DEF
        GHI""".indent(4);
```

```java
//Good
String text = """
            ABC
            DEF
            GHI\
        """;
```

### 2.7.29. ストリーム（InputStream OutputStream）

#### 2.7.29.1. ストリームを扱う API を利用するときは、try-with-resources 文で後処理をします

```java
//Good
try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
    //inputStreamに対する処理を記載
}
```

#### 2.7.29.2. `ObjectOutputStream` では`reset()`を利用します

[ObjectOutputStream](https://docs.oracle.com/javase/jp/7/api/java/io/ObjectOutputStream.html)

### 2.7.30. リソースの解放

#### 2.7.30.1. リソース解放を必要とするクラスを利用するときは、try-with-resources 文で後処理をします

```java
//Good
try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
    //inputStreamに対する処理を記載
}
```

#### 2.7.30.2. リソース解放を必要とするクラスを作成する場合は`AutoCloseable`を`implements`します

`AutoCloseable`を`implements`することで try-with-resources 文が利用できるようになります。

### 2.7.31. 例外

#### 2.7.31.1. catch 文で受け取る例外は、詳細な例外クラスで受け取リます

```java
//Bad
try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
    //・・・
} catch (Exception e) {//範囲が広すぎる例外クラスの利用はNG
    log.error("Error", e);
    throw e;
}
```

```java
//Good
try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
    //・・・
} catch (IOException e) {
    log.error("Error", e);
    throw e;
}
```

#### 2.7.31.2. `Exception` クラスのオブジェクトを生成してスローしてはいけません

```java
//Bad
try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
    //・・・
} catch (IOException e) {
    log.error("Error", e);
    throw new Exception(e); //例外が隠蔽され、呼出元で適切なcatchが難しくなります
}
```

#### 2.7.31.3. `catch` ブロックでは基本、例外処理をする。ただし処理を書いてはいけない部分もあるので、その部分については、"`// ignore`" というコメントを記述してください

```java
//Good
try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
    //・・・
} catch (IOException e) {
    log.error("Error", e);
    throw e;
} catch (IndexOutOfBoundsException e) {
    // ignore
} catch (Exception e) {
    log.error("Error", e);
    throw e;
}
```

#### 2.7.31.4. 例外クラスを勝手に定義することは禁止します

各人が勝手に例外クラス（Exception）を作成すると、適切な例外キャッチが困難になります。

プロジェクトの責任者に許可をとって追加してください。

### 2.7.32. ガベージコレクション

#### 2.7.32.1. 原則`finalize()`のオーバーライド実装は禁止します

`finalize()`メソッドは、ガーベージコレクションを実行するためのメソッドです。

オーバーライドは禁止します。

もし`finalize()`をオーバーライドした場合は`super.finalize()` を呼び出だしてください。

また、アプリケーションから`finalize()`を呼び出さないでください。

---

## 2.8. 注意事項

禁止とまではいきませんが、バグを防いだり保守性を損なわないために、注意事項を定めています。

### 2.8.1. メソッドには名前から想像できない処理を実装しないでください

メソッド名から想像できない処理が実装されていると、そのメソッドの使用者は混乱します。

```java
//Bad
//メソッド名からは「未読通知を取得する」処理だと想像できるが、
//実際には「既読状態への更新」も行っている
private List<Notification> findUnreadNotifications() {
    final List<Notification> notifications = dao.findUnreadNotifications();

    //未読から既読へ更新している
    for (Notification notification : notifications) {
        notification.setStatus(Status.ALREADY_READ);
        dao.update(notification);
    }

    return notifications;
}
```

```java
//Good
//メソッド名から想像できる通り「未読通知を取得する」処理を行っている
private List<Notification> findUnreadNotifications() {
    return dao.findUnreadNotifications();
}

//「既読状態への更新」は別メソッドとしている
private void updateToAlreadyRead(List<Notification> notifications) {
    for (Notification notification : notifications) {
        notification.setStatus(Status.ALREADY_READ);
        dao.update(notification);
    }
}
```

実装中はメソッドを使うのは自分だけなので大丈夫だと思っていても、コードレビューや保守など実装以降のフェーズになると他人の目に触れる機会があります。

誰が見ても自然に映るよう、「名は体を表す」ようなメソッドを実装してください。

### 2.8.2. 単一のメソッドに複数の要素を詰め込まないでください

単一のメソッドに「取得」「更新」「チェック」といった複数の要素を詰め込まないでください。
複数の要素を詰め込んだメソッドの名前は、`execute`や`update`など抽象的なものになりがちです。

アプリケーションのコードは「プレゼンテーション」や「ビジネスロジック」、「データアクセス」といったレイヤーに分かれています。
それぞれのレイヤーによって抽象度は異なるので一概にはいえませんが、アプリケーションプログラマーが書くビジネスロジックでは単一のメソッドには複数の要素を詰め込まず具体的な名前を付けるよう努めてください。

### 2.8.3. クラス外に公開されるメソッドの引数や戻り値・フィールドの型は実装クラスではなくインターフェースで宣言してください

クラス外に公開されるメソッドの引数や戻り値、フィールドの宣言には実装クラスではなくインターフェースを使用してください。

引数を実装クラスで宣言していると、引数の型を変更した場合に呼び出し元のコードも変更しなくてはいけません。

```java
//Bad
//Listではなく、実装クラスであるArrayListで宣言している
public void saveItems(final ArrayList<Item> items) {
    ...
}
```

```java
//saveItemsメソッドを呼び出しているコード
//もしsaveItemsの引数がArrayListからLinkedListに変更された場合、
//こちらのコードも変更する必要がある（NG）
final ArrayList<Item> items = ...
dao.saveItems(items);
```

引数をインターフェースで宣言していると、そもそも実装クラスは呼び出し元で用意するものなので、上記のような問題は起きません。

```java
//Good
//Listインターフェースで宣言している
public void saveItems(final List<Item> items) {
    ...
}
```

戻り値を実装クラスで宣言している場合も、呼び出し元のコードで戻り値を受け取っている変数の型が実装クラスになっていると、やはり戻り値の型を変更した場合に呼び出し元のコードも変更しなくてはいけません。

```java
//Bad
//Listではなく、実装クラスであるArrayListで宣言している
public ArrayList<Item> findAllItems() {
    ...
}
```

```java
//findAllItemsメソッドを呼び出しているコード
//もしfindAllItemsの戻り値がArrayListからLinkedListに変更された場合、
//こちらのコードも変更する必要がある（NG）
final ArrayList<Item> allitems = dao.findAllItems();
```

引数とは違って、呼び出し元コードの方で宣言している変数の型をインターフェースにしておけば実害はありません。
しかし、変数の型を実装クラスで宣言してしまう余地をなくすためにも、戻り値の型もインターフェースで宣言するようにしてください。

```java
//Good
//Listインターフェースで宣言している
public List<Item> findAllItems() {
    ...
}
```

`private`メソッドや`private`フィールドはクラス内に閉じており影響範囲が狭いので実装クラスで宣言しても構いませんが、そうする強い理由が無ければインターフェースで宣言しておいてください。

また、ローカル変数はメソッド内に閉じており影響範囲がかなり狭いので実装クラスで宣言しても構いません。
なお、Java 10から導入された`var`を使用してローカル変数を宣言すると、右辺の式を評価した結果の型として扱われます。
これはローカル変数の型を実装クラスで宣言していることと同義です。

```java
//Good
public void someMethod() {

    //ローカル変数なので実装クラスで宣言してもOK
    ArrayList<String> localVariable = new ArrayList<>();

    //Java 10から導入されたvarでローカル変数を宣言してもOK
    //この場合は右辺の値がArrayListなので、ArrayListで宣言したものとして扱われる
    //※ダイヤモンドオペレーターが使えず、右辺で型パラメータをバインドしなくてはいけない点に注意
    var useVarKeyword = new ArrayList<String>();

    ...
}
```

### 2.8.4. メソッドのオーバーロードはオプションの省略用途のみに使用してください

引数の順番が入れ替わっただけのメソッドをオーバーロードしたり、まったく異なる型の引数を取るメソッドをオーバーロードするとコードが複雑になります。

メソッドのオーバーロードはオプション扱いの引数を省略したメソッドを定義する場合にのみ使用してください。
その際も、引数の順番に注意をして後ろの引数から省略するようにメソッドを設計してください。

```java
//Bad
//引数の順番が変わっただけのオーバーロード
public void updateItem(final ItemCode code, final String name, final int version) {
    ...
}

public void updateItem(final ItemCode code, final int version, final String name) {
    ...
}

public void updateItem(final String name, final int version, final ItemCode code) {
    ...
}
```

```java
//Bad
//全く異なる型の引数を取るオーバーロード
public void updateItem(final ItemCode code, final String name, final int version) {
    ...
}

public void updateItem(final ItemCode code, final LocalDateTime updatedAt) {
    ...
}
```

```java
//Good
//オプションの引数を省略するオーバーロード
public void updateItem(final ItemCode code, final String name, final int version) {
    LocalDateTime defaultUpdatedAt = ...
    updateItem(code, name, defaultUpdatedAt);
}

public void updateItem(final ItemCode code, final String name, final int version, final LocalDateTime updatedAt) {
    ...
}
```

### 2.8.5. 未使用コードは残したままにしないでください

試行錯誤や性能改善の過程で使用されなくなったメソッドや変数、デバッグ用のコードなどは残したままにせず削除してください。

ただし、次のような未使用コードは例外として扱います。
これらは削除せずに残しておいてください。

- フレームワークの制約で、必ず定義しないといけないメソッドや変数
- 自動生成されたコードに含まれる未使用メソッド・変数

### 2.8.6. クラスは大きくなりすぎないようにしてください

クラスが大きすぎると内容の把握が難しくなり、保守性が低くなります。
そのような場合は、クラスを分割することを検討してください。

フィールドはクラスの状態を表すものですが、中でも変更可能なフィールドが多いとクラス全体の把握が難しくなります。
なるべく変更可能なフィールドを減らすか、分割して別のクラスに移動してください。

ただし次に示すようなデータの入れ物として機能するクラスは、変更可能なフィールドが多くなる傾向にありますが意味のある単位でクラスが作られているので分割しないでください。

- データベースのテーブルをマッピングするエンティティクラス
- HTMLのフォームをマッピングするフォームクラス

### 2.8.7. メソッドは大きくなりすぎないようにしてください

メソッドが大きすぎると処理の把握が難しくなり、保守性が低くなります。
そのような場合は、メソッドを分割することを検討してください。

もっと簡単なのはある程度の塊ごとに`private`メソッドへ切り出すことです。

また、メソッドの引数の個数も多くなりすぎないようにしてください。

### 2.8.8. インナークラスやstaticにネストしたクラス、匿名クラスは作りすぎないようにしてください

インナークラスや`static`にネストしたクラス、匿名クラスの使用を特に禁止しませんが、これらのクラスを作りすぎてしまうとコードの可読性が低くなってしまいます。

もし大量のインナークラスや`static`にネストしたクラス、匿名クラスが必要な場合は、別の独立したクラスに切り出せないか検討してみてください。

### 2.8.9. 可能な限りキャストは使用しないでください

キャストはある型として扱っている値を強制的に異なる型として扱うようにする仕組みで、「コンパイルは通っているけれど、実行時にエラーが出る」といった状況を引き起こす原因になります。

Java 5からジェネリクスが導入されて、キャストを使用しなくてもほとんど困ることはなくなっています。

### 2.8.10. ラッパークラスの変数とプリミティブ値を演算する際は、アンボクシングに注意してください

`java.lang.Integer`のようなラッパークラスを`int`のようなプリミティブ値へ変換することをアンボクシングと言います。

ラッパークラスの変数はプリミティブ値を伴う演算を行う場合、コンパイラーによって自動でアンボクシング処理が差し込まれます。

```java
final Integer a = ...
final int b = ...

//コンパイラーによって変数aに対してintValueメソッド呼び出しが差し込まれる
//つまり実際の処理は final int c = a.intValue() + b; となる
final int c = a + b;
```

自動でアンボクシングが差し込まれるのは便利ですが、ラッパークラスの変数が`null`の場合にアンボクシングすると`java.lang.NullPointerException`がスローされてしまいます。

```java
final Integer a = null;
final int b = ...

//変数aがnullの場合、コンパイラーによって差し込まれたintValueメソッド呼び出しでNullPointerExceptionがスローされてしまう
final int c = a + b;
```

このため、ラッパークラスの変数とプリミティブ値を演算する場合は`null`チェックを行うなど、注意をしてコーディングしてください。

```java
final Integer a = ...
final int b = ...

if (a != null) {
    final int c = a + b;
    .
    .
    .
}
```

### 2.8.11. 計算の誤差が許されない場合はBigDecimalを使用してください

`float`と`double`は浮動小数点数と呼ばれる方法で表現される数値型ですが、浮動小数点数の計算はいくつかのケースで誤差を生じることがあります。

GUIの座標計算のように多少の誤差を無視できる場合は浮動小数点数を使用しますが、金利や値引きなどのように誤差が許されない場合は`java.math.BigDecimal`を使用してください。

```java
//Bad
final double discountRage = 0.07;
return 1 - discountRate; //0.9299999999999999
```

```java
//Good
final BigDecimal discountRate = new BigDecimal("0.07");
return BigDecimal.ONE.subtract(discountRate); //0.93
```

なお、`BigDecimal`のコンストラクタには`double`の値を受け取るものがありますが、浮動小数点数で発生する誤差と同じような誤差が発生する場合もあるので使用しないでください。
`double`の値から`BigDecimal`インスタンスを得たい場合は`valueOf`メソッドを使用してください。

```java
//Bad
final BigDecimal discountRate = new BigDecimal(0.07); //doubleの値を渡してインスタンス化
return BigDecimal.ONE.subtract(discountRate); //0.929999999999999993338661852249060757458209991455078125
```

```java
//Good
final BigDecimal discountRate = BigDecimal.valueOf(0.07); //doubleの値をvalueOfに渡してインスタンス化
return BigDecimal.ONE.subtract(discountRate); //0.93
```

また、`BigDecimal`の`equals`メソッドは値とスケールが同じである場合に等しいと見なします。
ですので、2つの`BigDecimal`の値を比較する場合は`compareTo`メソッドを使用してください。

```java
//Bad
final BigDecimal value = new BigDecimal("10.0"); //スケールは1
if (value.equals(BigDecimal.TEN)) { //BigDecimal.TENのスケールは0なのでequalsはfalseを返す
    ...
}
```

```java
//Good
final BigDecimal value = new BigDecimal("10.0"); //スケールは1
if (value.compareTo(BigDecimal.TEN) == 0) { //comareToはスケールが異なっても値が等しい場合は0を返す
    ...
}
```

`BigDecimal`は誤差のない計算ができる他、`java.math.RoundingMode`で多数の丸めモードをサポートしています。

### 2.8.12. ソートと集計はJava側ではなく、SQLで行うようにしてください

データベース内のデータのソートや集計はJava側ではなくSQLで行ってください。

データが少量であればJava側でソートを行っても問題はありませんが、データが大量だと性能劣化の原因となります。
また、データベースから少量ずつフェッチして処理を行う場合はそもそもJava側でソートができません。

集計は通常、大量データに対して行うものですので、これもJava側で行うと性能劣化の原因となります。
それにソートと異なり集計前のデータは一時的に使用するもので、本当に必要なのは最終的な集計結果です。
このことからも`SUM`や`AVR`などの集計関数を使用してSQLで集計を行ってください。

### 2.8.13. ループ処理の中では極力データベースアクセスしないようにしてください

業務アプリケーションでは、データベースから取得したデータをループで1件ずつ処理することがよくあります。

このとき、ループの中で追加の情報を取得するためにデータベースへアクセスしないようにしてください。
データベースアクセスの回数が多くなり、性能劣化の原因となります。

可能な限り、最初のデータ取得時にテーブル結合を使用して1回のデータベースアクセスで必要な情報を取得するようにしてください。

### 2.8.14. 外部からの入力値は共通部品を用いてチェックしてください

アプリケーション外部からの入力値にはいくつかの種類があります。
次に3つの例を挙げます。

- ブラウザから送信されたフォームの値
- 外部システムから連携されたファイルの内容
- MQで連携されたメッセージ

これらの値は必ず入力仕様にて、チェックをしてください。
たとえばブラウザから送信されたフォームの値であれば[Bean Validation](https://beanvalidation.org/)を使用してバリデーションを行ってください。
他のものも同様で、フレームワークが提供している機能を使用して入力値チェックを行ってください。

なお「アプリケーション外部からの入力値」というとデータベースから取得したデータも該当しますが、自分たちの完全にコントロールしているデータにはすでにチェック済みの信頼できる値が格納されています。
このことから、データベースから取得したデータは入力値チェック対象外です。
他システムからのデータ連携など、信頼できないデータの場合は、同様に入力値チェックが必要です。

### 2.8.15. ファイル入出力は共通部品のクラスを使用してください

アプリケーションプログラマーが思い思いにファイル入出力を行うと文字コードや改行コードの取り扱いを統一させるのに労力がかかります。

プロジェクト責任者はプロジェクトで定めるファイルフォーマット仕様に基づいて、ファイル入出力の共通部品を作成してください。
そしてアプリケーションプログラマーはファイル入出力を行う際は、共通部品のクラスを使用してください。

不足機能は共通部品に追加する方向でプロジェクト責任者へ依頼・相談してください。

共通部品を使ってファイル入出力を行うことで文字コードや改行コードの取り扱いを統一できます。
また、共通部品内で要求されたファイルパスのチェックを行うことでディレクトリトラバーサルを防げます。

### 2.8.16. リソースをクローズする必要がある場合はtry-with-resources構文を使用してください

`java.io.InputStream`や`java.io.OutputStream`など、外部リソースを使用するオブジェクトは`try-with-resources`構文を使用してクローズ漏れがないようにしてください。

`try-with-resources`構文はJava 7で導入されました。

```java
//Bad
//Java 6までのレガシーな書き方
final InputStream in = openStream();
try {

    final String content = readAsString(in);

} finally {
    in.close();
}
```

```java
//Good
//Java 7以降のtry-with-resources
try (final InputStream in = openStream()) {

    final String content = readAsString(in);

}
```

### 2.8.17. 例外処理はプロジェクトの方式設計にしたがって統一的にコーディングしてください

例外処理方式はプロジェクトで統一されていることが重要になります。
プロジェクトの方式設計にした統一的にコーディングしてください。

### 2.8.18. ループのネストはできれば二重までにしてください

ループのネストが深くなるとコードの可読性が低下します。
可読性は主観によるものなのでこの指標は絶対ではないですが、本規約ではループのネストは二重までと定めます。
